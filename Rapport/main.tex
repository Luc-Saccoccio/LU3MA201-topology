%! TeX program = lualatex
\documentclass[a4paper, 12pt]{article}

\usepackage{fontspec}
\usepackage{multicol}
\usepackage[french]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{enumitem}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{wrapfig}
\usepackage[french]{datetime}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{array}
\usepackage{hyperref}
\usepackage{minted}

% Required for UTF-8 characters in minted env
\setmonofont{FiraCode}

\setminted[lean]{linenos, fontsize=\footnotesize}

\newcommand{\lean}[1]{\mintinline{lean}{#1}}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    pdftitle={Démonstration assistée par ordinateur},
}

\urlstyle{same}

\begin{document}

\begin{titlepage}

    \begin{figure}
        \centering
        % \includegraphics[width=8cm]{logo.png} % Logo Sorbonne
        \vspace{8cm}
    \end{figure}

    \vspace{6cm}

    \begin{center}
        {\Huge Démonstration assistée par ordinateur\\}
        \vspace{0.5cm}
        {\huge Rapport de mi-parcours\\}

        \vspace{1.5cm}

        {\large Luc Saccoccio--Le Guennec\\ Nour Bouabid\\ Charles De Vergeron}
        \vfill
        {\large \today}
        \pagebreak
    \end{center}

\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}

\subsection{Assistants de preuves}

Un assistant de preuve est un logiciel permettant l'écriture d'énoncés logiques et la vérification de preuves formelles. Il existe de nombreux assistants de preuves, parmi lesquels on peux citer :

\begin{itemize}
    \item Coq, développé en OCaml par l'équipe \href{http://www.pps.univ-paris-diderot.fr/pi.r2/}{PI.R2}
    \item Isabelle, développé en Standard ML et Scala
    \item Agda, développé en Haskell
\end{itemize}

On peut noter qu'ils diffèrent sur de nombreux points. En prenant Coq comme standard :

\begin{itemize}
    \item Isabelle n'est pas en capacité de raisonner avec des types dépendants
    \item Agda ne dispose pas de mécanismes d'automatisation de preuves
\end{itemize}

Qui plus est, il existe des langages de programmation dont le système de types permet la formalisation de certains énoncés, comme Haskell; ou n'ayant pas pour objectif de permettre la formalisation d'énoncés mathématiques mais plutôt la vérification de programmes informatiques, comme F*.

Le fonctionnement des assistants de preuves, autrement dit ce qui permet de s'assurer que l'assistant comprend bien les énoncés que nous encodons et qu'il a en effet raison lorsqu'il affirme que notre preuve est (ou n'est pas) acceptable; repose sur la, ou plutôt une théorie des types.

\subsection{Petit historique}

Ce qui suit est un historique extrêmement concis et réducteur de plus de 2 000 ans d'histoire d'une certaine branche de la logique.

L'histoire de la formalisation des mathématiques commence avec Aristote et l'introduction de la méthode axiomatique et de règles logiques. Après de nombreuses péripéties, on peut considérer que ces objectifs furent atteint par Frege pour la logique classique, et par Heyting pour la logique intuitionniste. Cette considération est néanmoins discutable, et en 1910 Whitehead et Russell introduisirent la notion de type pour y remédier dans les volumineux \textit{Principia Mathematica}. Malgré son efficacité à résoudre les problèmes ayant motivé sa création, c'est à dire les paradoxes de la théorie naïve des ensembles de Frege, cette théorie était assez rigide et ne formalisait pas le mécanisme de substitution. C'est avec le $\lambda$-calcul d'Alonzo Church en 1940 que ce mécanisme est formalisé, et il crée la théorie des types simples. En 1934 puis en 1958, Haskell Curry remarque qu'il y a une forme de correspondance entre les types et les schémas d'axiomes intuitionnistes, puis de même entre certains modèles de preuves et certains modèles de calcul. Enfin, en 1969, William Alvin Howard observe que la déduction naturelle peut s'interpréter comme sa version intuitionniste vu comme une version typée du $\lambda$-calcul :

\begin{center}
    Il y a un isomorphisme entre les $\lambda$-termes et les preuves, et entre leurs types et les énoncés logiques.
\end{center}

C'est la correspondance de Curry-Howard(-Lambek pour la version catégoriste)

Dans les années 70, de Bruijn étend le système de types en introduisant les types dépendants avec pour objectif affiché de formaliser et vérifier les mathématiques. Il crée alors le premier assistant de preuve, \textbf{AUTOMATH}. En 1973, un autre assistant de preuve, Mizar, est développé, mais sur des bases ensemblistes (en particulier la théorie des ensembles de Tarski-Grothendieck). Il est publié en 1989. Mais à partir des années 80, il y a une explosion de la recherche en ce domaine, avec Per Martin-Löf, Girard et Barendregt...

L'histoire est parcellée de péripéties, mais nous finirons cet historique en 2004 avec la formalisation en Coq du théorème des quatres couleurs. Bien que ce résultat fut prouvé maintes fois (en 1976 par Appel et Haken, 1996, 1997...) y compris sur des assistants de preuves, la formalisation en Coq réduit d'une part les programmes à un seul : le noyau de Coq, et d'autre part automatise les très nombreux configurations à prendre en compte.

\subsection{Ce projet}

Ce projet a pour but d'implémenter une partie de notre cours de topologie métrique (LU3MA260) dans l'assistance de preuve \href{https://lean-lang.org/}{Lean}. Cela implique donc de commencer par définir les objets étudiés (espaces métriques, boules, applications continues...) puis d'encoder et de vérifier nos théorèmes et preuves.

\section{Lean}

Pour ce projet, nous utiliserons l'assistant de preuves Lean (version 4.5.0 lors de l'écriture de ce rapport). Il y a plusieurs raisons pour ce choix parmi lesquelles :
\begin{itemize}
    \item L'environnement de développement interactif
    \item Le support natif des caractères unicode
    \item Les capacités de méta programmation
\end{itemize}

Outre, bien entendu, son utilisation dans D$\exists\forall$DUCTION \cite{deaduction}, sa simplicité d'apprentissage, la documentation (\cite{theorem_proving}, \cite{math_in_lean}) et la communauté Lean sur Zulip pouvant répondre à nos interrogations.

Nous utilisons essentiellement Mathlib, une librairie contenant un vaste ensemble de résultats mathématiques, pour des structures usuelles comme les réels ainsi que pour conclure des preuves nécessitant la manipulation d'inégalités, cela n'était pas très intéressant.

\subsection{Histoire}

Lean est un langage open-source développé depuis 2013 basé sur le calcul des constructions (la version du lambda-calcul la plus "forte" selon la classification de Barendregt \cite{Barendregt_1991}), tout comme Coq. Bien que les premiers essais aient contenus des fondations alternatives (notamment la théorie homotopique des types), en 2017 sort Lean 3, la première version stable implémentée majoritairement en C++. En 2021 commence Lean 4, une réimplémentation de Lean majoritairement en Lean avec certaines parties en C++. Cette version contient en outre un système de macros extrêmement puissant qui permet d'implémenter et de modifier un ensembles de composants du frontend en Lean plutôt qu'en C++.

\subsection{Cycle de développement}

Un projet Lean commence par la création d'un dossier dédié à l'aide du programme \texttt{lake}. On peut alors préciser que l'on compte utiliser Mathlib dans le fichier \texttt{lakefile.lean}. Ensuite on peut commencer à programmer ou prouver des résultats. Seul le second cas nous intéresse. L'arborescence d'un projet Lean consiste en un unique dossier portant le nom du projet, lequel contient un ensemble de dossiers et de fichiers Lean.

\subsection{Méta programmation}


\section{La topologie métrique en Lean}

\subsection{Contexte et mise en place}

Le cours de topologie LU3MA260\cite{topology_memo} est divisé 5 parties et 2 appendices :

\begin{itemize}
    \item Espaces métriques
    \item Complétude
    \item Compacité
    \item Connexité
    \item Espaces vectoriels normés, espaces de Banach
    \item Appendice I : ensembles et applications
    \item Appendice II : quelques schémas
\end{itemize}

Nous laisserons de côté les appendices ainsi que la dernière section sur les espaces vectoriels normés et les espaces de Banach.

\subsection{Espaces métriques}

On commence par définir un espace métrique. C'est une classe de types sur lesquels on peut définir une "distance", c'est à dire la donnée de l'application et des propriétés qu'elle vérifie :

\begin{minted}{lean}
class MetricSpace (α : Type u) where
    dist : α → α → ℝ
    dist_pos : ∀ {x y : α}, 0 ≤ dist x y
    dist_sep : ∀ {x y : α}, dist x y = 0 ↔ x = y
    dist_symm : ∀ {x y : α}, dist x y = dist y x
    dist_triangle : ∀ {x y z : α}, dist x z ≤ dist x y + dist y z

variable {X : Type u} [MetricSpace X]
\end{minted}

La dernière instruction, \lean{variable}, permet de définir dans le contexte (soit le fichier, soit la \lean{section} dans laquelle on se trouve) des variables. Ici, nous nous sommes donnés un type \lean{X} dans l'univers \lean{u}, ainsi qu'une instance de la classe \lean{MetricSpace} pour le type \lean{X}. En termes mathématiques, nous nous sommes donnés un espace métrique $X$.

On définit ensuite les boules ouvertes et on introduit la notation usuelle $B(x, r)$ pour la boule de rayon $r$ centrée en $x$. Le type \lean{Set X} est le type des ensembles à valeurs dans \lean{X}.

\begin{minted}{lean}
def open_ball (x : X) (r : ℝ) : Set X := {y | d x y < r}

notation "B(" x "," r ")" => open_ball x r
\end{minted}

Il est très pratique d'introduire un ensemble de lemmes relativement évidents qui faciliteront les preuves. Ils sont tous marqués avec \lean{@[simp]}, ce qui indique à Lean qu'il peut les utiliser lors de l'application des tactiques `simp` :

\begin{minted}{lean}
@[simp]
lemma dist_sep_eq_zero (x : X) : d x x = 0 := dist_sep.mpr rfl

@[simp]
lemma mem_open_ball (x : X) (r : ℝ) (y : X) : y ∈ B(x, r) ↔ dist x y < r := Iff.rfl

@[simp]
lemma center_in_ball (x : X) (r : ℝ) : r > 0 → x ∈ B(x, r) := by
  intro r_pos
  simpa [open_ball]
\end{minted}

On finit enfin par la définition d'un ouvert. C'est un objet de type \lean{Prop}, autrement dit un énoncé mathématique, paramétré par l'ouvert $U$.

\begin{minted}{lean}
def is_open (U : Set X) : Prop := ∀ x ∈ U, ∃ r > 0, B(x, r) ⊆ U
\end{minted}

On peut alors montrer un premier résultats, c'est à dire que le boule ouverte est bien ouverte :

\begin{minted}{lean}
lemma open_ball_is_open : ∀ x : X, ∀ r > 0, is_open B(x, r) :=
  by
    intros x r _ y y_in
    set ε := r - d x y with hε
    use ε
    apply And.intro
    . simp [open_ball] at y_in
      linarith only [hε, y_in]
    . intros z z_in
      rw [mem_open_ball] at *
      have p : d x z ≤ d x y + d y z := dist_triangle
      linarith only [p, z_in, y_in, hε]
\end{minted}

Pour ce qui est de la preuve, elle suit le raisonnement suivant :

\begin{itemize}
    \item On introduit les variables \lean{x}, \lean{r}, \lean{y} et l'hypothèse \lean{y_in} que \lean{y} est dans la boule \lean{B(x, r)}.
\end{itemize}

La preuve consiste en l'introduction de \lean{x}, \lean{r}, \lean{y} et de l'hypothèse que \lean{y} est dans la boule \lean{B(x, r)} (l'underscore après \lean{r} signifie simplement que l'on ne nomme pas l'hypothèse que \lean{r} est positif). On peut ensuite définir notre $ε$ ainsi que l'hypothèse \lean{hε} qui a pour type \lean{ε = r - d x y}. Puisque \lean{is_open U} a pour type \lean{∀ x ∈ U, ∃ r > 0, B(x, r) ⊆ U}, il faut donc montrer \lean{∃ r > 0, B(x, r) ⊆ U}. Cette syntaxe signifie en réalité \lean{∃ r, r > 0 ∧ B(x, r) ⊆ U} (\lean{∃} étant une syntaxe pour le type inductif \lean{Exists} paramétré par \lean{w} et \lean{h}, l'élément et la propriété sur cet élément). On indique donc que l'on utilise \lean{ε} et il reste à montrer la positivité et l'inclusion de la boule. La positivité s'obtient en revenant à la définition d'une boule ouverte puis en appliquant la tactique \lean{linarith} qui résout un but à l'aide d'arithmétique linéaire.

\subsection{Complétude}


\subsection{Compacité}

\subsubsection{Définition}

\begin{minted}{lean}

variable {X Y : Type u} [MetricSpace X] [MetricSpace Y]

\end{minted}

On introduit deux espaces métriques $(X,d_{X})$ et  $(Y,d_{Y})$ grâce à la tactique \lean{variable}. X et Y sont munis des distances respectives \lean{d_{X}} et \lean{d_{Y}} défini par \lean{MetricSpace X} et \lean{MetricSpace Y}, ainsi le type X désignera  $(X,d_{X})$ et le type Y désignera $(Y,d_{Y})$ .\\

D'après le cours un espace métrique \lean{X} est compact si et seulement si de toute suite d'éléments de \lean{X} on peut extraire une sous-suite convergente. Nous définirons un compact par cette propriété. Mais avant voici quelque lemmes et définitions préliminaires. 

\begin{minted}{lean}
def strictement_croissante (f : ℕ → ℕ ) : Prop := ∀ n m : ℕ, n > m -> f n > f m

def croissante (f : ℕ → ℕ) : Prop := ∀ n m : ℕ, n >= m → f n >= f m

\end{minted}

\lean{croissante} et \lean{stricte_croissante} sont les définitions respectives de la croissance et stricte croissance d'une fonction de $\mathbb{N}$ dans $\mathbb{N}$. Ensuite le lemme \lean{stricte_croissante_to_croissante} prouve qu'une fonction strictement croissante est croissante:

\begin{minted}{lean}
lemma stricte_croissante_to_croissante (f : ℕ → ℕ) : strictement_croissante f → croissante f :=
  by
    intro hf n m hnm
    apply Or.elim (Nat.eq_or_lt_of_le hnm)
    . exact Nat.le_of_eq ∘ congrArg f
    . exact Nat.le_of_lt ∘ hf n m
    
\end{minted}



Cette preuve consiste en l'introduction de \lean{hf} l'hypothèse de la strict croissance de \lean{f} , \lean{n} et \lean{m} deux entiers naturels et \lean{hnm} l'hypothèse $ \lean{n} \geq \lean{m} $. Le but est de type $ \lean{f n} \geq \lean{f m} $. Le lemme de mathlib \lean{Nat.eq_or_lt_of_le} appliqué à \lean{hnm} montre que $ \lean{n} \geq \lean{m} $ implique "soit $ \lean{n} = \lean{m} $ soit $ \lean{n} \geq \lean{m} $ ". Ainsi par composition avec la tactique \lean{apply Or.elim}, on obtient une disjonction de cas. Nous obtenons alors deux buts. Le premier, \lean{m = n -> f n >=  f m}  se montre par la fonction \lean{congrArg}, elle prend en argument \lean{f} et renvoie que l'égalité des antécédents implique l'égalité des images. Puis le lemme de mathlib \lean{Nat.le_of_eq} élargi l'égalité des images à l'inégalité souhaitée. Le second but \lean{ n > m -> f n >= f m} se montre par \lean{hf} avant d'élargir l'inégalité strict par \lean{Nat.le_of_lt}\\



Enfin voici le lemme \lean{stricte_croissance_geq} qui nous servira également pour la suite:

\begin{minted}{lean}

lemma stricte_croissance_geq (f : \Nat → \Nat) : strictement_croissante f → ∀ n : ℕ, f n >= n :=
  by
    intro h n
    induction' n with n hi
    . exact Nat.zero_le (f 0)
    . exact Nat.succ_le_of_lt ∘ Nat.lt_of_le_of_lt hi \textdollar h (n + 1) n (Nat.lt_succ_self n)
\end{minted}   
    

Nous pouvons à présent prouver que si une suite converge alors toute suite extraite converge vers la même limite:    

\begin{minted}{lean}    
    

lemma limite_suite_extraite ( K:Set X) (x : ℕ → K) (l : X) (f : ℕ → ℕ) : lim  x l ∧ strictement_croissante f -> lim  (x ∘ f) l :=
  by
    rintro ⟨hx, hf⟩ ε hε
    obtain ⟨N, hN ⟩ := hx ε hε
    use N
    intro n hn
    have t : f n >= f N := stricte_croissante_to_croissante f hf n N hn
    apply hN
    have sup_N: f N >= N := stricte_croissance_geq f hf N
    linarith [t, stricte_croissance_geq f]
    
\end{minted}

Dans ce contexte la tactique \lean{rintro} permet d'introduire séparément \lean{hx} ( de type lim x l) et \lean{hf} ( de type \lean{strictement_croissante f}), le but étant une implication, les hypothèses de départ sont introduites en premier. \lean{rintro} introduit ensuite \lean{ε} et \lean{hε} (de type \lean{ε>0} d'après l'expression du but qui commence par le quantificateur $\forall$ (voir définition de \lean{lim}).

Ainsi on obtient \lean{N} un entier naturel et \lean{hN} de type \lean{∀ n ≥ N, d l ↑(x n) < ε} par \lean{hx} appliqué à \lean{ε} et \lean{hε}.

Le but étant alors \lean{∃ N, ∀ n ≥ N, d l ↑((x ∘ f) n) < ε}, la tactique \lean{ use N} fait que le but soit de montrer que \lean{N} convient. 

On introduit alors \lean{n} et \lean{hn} puisque le but commence encore une fois par le quantificateur $\forall$. 

Il reste à montrer \lean{d l ↑((x ∘ f) n) < ε}. Nous appliquons \lean{ hN} au but, ainsi il reste à montrer que \lean{f n ≥ N}. 

\lean{stricte_croissante_to_croissante} démontrée précédemment appliquée à \lean{f} et \lean{hf} nous donne la croissance de \lean{f}. Puis la définition de la croissance de \lean{f} appliquée à \lean{n},\lean{N} et \lean{hn} nous donne la propriété que nous avons nommé t par la tactique have.

De même, \lean{ stricte_croissance_geq} appliqué à \lean{f}, \lean{hf} et \lean{N} nous donne la propriété que nous avons nommée\lean{sup_N}.

Enfin, par combinaison linéaire de ces deux dernières hypothèses,la tactique \lean{linarith} résout automatiquement le but.

\begin{minted}{lean}
def lim' (x : ℕ → α) (l : α ) [MetricSpace α  ]:= ∀ ε > 0, ∃ N : ℕ, ∀ n ≥ N, d l (x n) < ε
\end{minted}

Cette définition de la limite prend en argument une suite \lean{x} de $\mathbb{N}$ dans $\alpha$, un type quelquonc de l'univers \lean{u} à partir duquel on construit un espace metrique grace à la syntaxe \lean{[MetricSpace α  ]}. \lean{lim'} prend en second argument un élément de $\alpha$, puis elle defini la convergence de la suite \lean{x} vers cet élément.

Nous pouvons à présent définir un espace métrique compact:

\begin{minted}{lean}

def Compact (K : Type u) [MetricSpace K]  : Prop := ∀ x : ℕ → K , ∃ f : ℕ → ℕ,  ∃ l,  (strictement_croissante f ∧  lim' ( x ∘ f) l)
\end{minted}

Cette définition prend encore une fois un type quelquonc  de u en argument et elle en fait un espace métrique. Pour toute suite \lean{x}, l'existence d'une suite extraite est par définition équivalente à l'existence d'une fonction strictement croissante de $mathbb{N} $ dans $mathbb{N} $  que l'on compose par \lean{x}. Ainsi, la compacité se défini  par l'existence d'une telle fonction ainsi que celle d'un élément \lean{l} vers lequel la fonction composée converge.

\begin{minted}{lean}
def is_compact (K : Set X) : Prop := ∀ x : ℕ → K, ∃ f : ℕ → ℕ, ∃ l ∈ K, strictement_croissante f ∧ lim (x ∘ f) l

\end{minted}

Une partie d'un espace métrique est compact si le sous-espace métrique correspondant est compact. Etant donné que la distance se conserve pour tout sous-espace métrique, il n'est pas nécessaire de définir explicitement un nouvel espace métrique. Une partie \lean{K} de \lean{X} est un type de \lean{Set X} et tout élément de  \lean{K} est effectivement un type de \lean{X}. Ainsi  \lean{K} conserve les propriétées de \lean{X}. Il suffit donc d'ajuster la définition précédente en remplaçant \lean{∀ x : ℕ → X} par \lean{∀ x : ℕ → K}, ainsi que \lean{lim'} par \lean{lim}. En effet, \lean{lim} prend en argument une suite à valeur dans un type de \lean{Set X} et \lean{lim'} ne conviend qu'à une suite à valeurs dans \lean{X}.


\subsubsection{Compacité et fermeture}
Nous démontrerons dans cette partie quelques résultats sur la fermeture.

Tout d'abord, montrons qu'une partie compact de \lean{X} est fermé dans \lean{X}

\begin{minted}{lean}   
lemma compact_is_closed : ∀ K : Set X, is_compact K → is_closed K := 
  by
    intro K h
    contrapose! h
    have diff : Closure K ≠ K := by
      intro absurde
      have j : is_closed (Closure K) := by exact closure_is_closed
      rw [absurde] at j
      apply h at j
      exact j

    have c : K ⊂ Closure K :=
      Set.ssubset_iff_subset_ne.mpr ⟨sub_closure, diff.symm⟩
    have l_in_closure_not_in_K : ∃ l : X, l ∈ Closure K ∧ l ∉ K :=
      Set.exists_of_ssubset c

    rcases l_in_closure_not_in_K with ⟨l, l_in_closure, l_not_in_K⟩
    obtain ⟨x, hx⟩ := (sequential_closure K l).mp l_in_closure

    intro compacite
    choose f l' hl' hf lim_l' using compacite x
    have lim_l : lim (x ∘ f) l := limite_suite_extraite K x l f ⟨hx, hf⟩
    have egalite: l=l':= by apply unicite_limite K (x∘f) l l' lim_l lim_l'
    rw [egalite] at l_not_in_K
    apply l_not_in_K at hl'
    exact hl'
\end{minted}

Comme le but est une implication de la forme $ \forall x, P(x) \implies Q(x)$, la tactique \lean{intro} introduit d'abord $x$ puis $P(x)$. Ici on nomme \lean{K} une partie compact, et \lean{h} l'hypothèse de sa compacité. Le but devient alors \lean{is_closed K}.

La tactique \lean{contrapose!} permet un raisonnement par contraposé. le but devient la négation de \lean{h} et \lean{h} devient la négation du but précédent.

Nous nommons \lean{diff} la propriété que l'adhérence de \lean{K} est diférente de \lean{K}. La tactique \lean{have} nous permet à la fois d'emboiter une "sous" preuve et de nommer la propriété prouvée. Par souci de clarté nous détaillerons la preuve de \lean{diff} dans un second temps. Nous ferons de même pour \lean{c : K ⊂ Closure K } puis \lean{l_in_closure_not_in_K}, preuve de l'existence de \lean{l} appartenant à l'adhérence de \lean{K} exclue de \lean{K}. 

\lean{recases} nous permet d'introduire séparément un tel \lean{l} puis les propriétés vérifiées par \lean{l}.

Ensuite par la tactique \lean{obtain}, nous appliquons le lemme \lean{sequential_closure} pour \lean{K} et \lean{l} dans le sens direct (\lean{.mp}).

Ainsi le critère de fermeture séquentielle nous donne l'existence d'une suite de \lean{K} convergente vers \lean{l}. \lean{obtain} nous permet d'introduire une telle suite ainsi que la propriété qu'elle vérifie puis de les nommer respectivement \lean{x} et \lean{hx}.

Enfin, Le goal étant la négation d'une proposition, \lean{intro} introduit cette proposition et change le but en \lean{False}. Ainsi par l'absurde nous montrerons que \lean{K} n'est pas compact. 

\lean{K} est supposé compact donc \lean{choose } applique la définition de la compacité à x, et prend alors une suite extraite de \lean{x} qui converge dans \lean{K }vers \lean{l'}, on nomme \lean{hl'} l'hypothèse que \lean{l'} est dans \lean{K}.

Nous prouvons ensuite que cette suite extraite converge vers \lean{l} par le lemme \lean{limite_suite_extraite} démontrée plus haut. Puis nous prouvons que \lean{l=l'} par unicité de la limite. 

La tactique \lean{rw} prend en argument une égalité et en précisant \lean{at l_not_in_K } elle remplace dans \lean{l_not_in_K} le membre de gauche par le membre de droite. Ainsi \lean{l_not_in_K} devient \lean{l'} n'apartient pas à \lean{K}. Ceci est en conctradiction avec \lean{hl'}. 

Par conséquent \lean{apply l_not_in_K at hl'} change \lean{hl'} en \lean{False}.

Enfin quand une hypothèse est égale au but, il suffit d'appliquer la tactique \lean{exact}, ce qui termine la preuve.\\


Revenons sur l'hypothèse \lean{diff}, le but est la négation d'une égalité, donc la tactique \lean{intro} introduit l'hypothèse de l'égalité et change le but en \lean{False}. Ceci nous permet de résonner par l'absurde. Ensuite, le lemme de la fermeture de l'adhérence appliqué à \lean{K} et nommé \lean{j}.\lean{rw} remplace alors \lean{Closure K} par \lean{K} dans \lean{j}. D'où une contradiction avec \lean{h}. Par conséquent \lean{apply h at j} change \lean{j} en \lean{False}. Encore une fois, \lean{j} est exactement le but, donc \lean{exact j} termine la preuve

L'hypothèse suivante \lean{c} est déduite de \lean{diff} par \lean{Set.ssubset_iff_subset_ne}, un lemme de mathlib utilisé dans le sens indirect (\lean{.mpr}). Il prend en argument \lean{sub_closure}, l'inclusion de tout ensemble dans son adhérence, en particulier pour \lean{K} (argument implicite), puis \lean{diff.symm} où \lean{.symm} permet d'inverser les membres de gauche et de droite.

Enfin l'hypothèse \lean{l_in_closure_not_in_K} est déduite de l'inclusion strict de \lean{c} par le lemme de mathlib \lean{Set.exists_of_ssubse}.\\


Les preuves suivantes seront moins détaillées afin d'éviter de trop se répéter, tous les théorèmes utilisés commençant par \lean{Set.},\lean{Fonction.}, et \lean{Nat.}  proviennent de Mathlib.\\


Poursuivons avec la proposition que toute partie fermée d'une partie compacte est compacte.


\begin{minted}{lean}   
lemma subcompact_closed_is_compact (K H: Set X) (k_compact : is_compact K) (h_sub: H  ⊆ K) (h_closed : is_closed H)  : is_compact H := by
  intro x
  have x_in_k : ∀ (n : ℕ), (x n : X) ∈ K := by
    intro n
    apply Set.mem_of_subset_of_mem h_sub
    apply (x n).2

  let y : ℕ → K := λ n ↦ ⟨x n, x_in_k n⟩
  obtain ⟨ f, l, _, croiss_f,lim_in_K⟩ := k_compact y

  have l_in_h : l ∈ Closure H := by apply (sequential_closure H l).mpr  ⟨ x∘f,lim_in_K⟩
  rw [closure_closed_is_closed] at l_in_h
  use f,l, l_in_h, croiss_f
  have eg : ∀ n , x n = (y n :X):= by
    intro n
    rfl
  have lim_xf : lim (x∘f) l := by
    intro ε hε
    obtain ⟨ N, hN⟩ := lim_in_K ε hε
    use N
    intro n hn
    specialize hN n hn
    have eg : x (f n) = (y (f n) : X) := eg (f n)
    rw [Function.comp_apply]
    rw [Function.comp_apply] at hN
    rw [<- eg] at hN
    exact hN
    
  exact  lim_xf
  exact h_closed
\end{minted}

Nous montrons que \lean{H} est compact. Nous prenons donc une suite \lean{x} à valeurs dans \lean{H} et nous montrons l'existence d'une suite extraite convergente.

Pour tout n, montrer que \lean{x n} est dans \lean{K} revient à montrer que \lean{x n} est dans \lean{H}, ceci découle de l'inclusion de \lean{H} dans \lean{K}, nous changeons le but de cette manière par \lean{Set.mem_of_subset_of_mem}. \lean{x n} contient la proposition d'appartenance à \lean{H} en deuxième position, nous appliquons donc \lean{(x n).2}

Par la compacité de\lean{K} nous posons une suite de \lean{K} coincidant avec \lean{x} et nous lui associons la suite extraite convergente \lean{y} composé par \lean{f}.

la limite \lean{l} de cette sous-suite est dans \lean{K} mais par \lean{sequential_closure} dans le sens indirect nous montrons que \lean{l} est dans l'adhérence de \lean{H}, en effet la composé \lean{x} par \lean{f} est une suite de \lean{H} et elle converge vers \lean{l} la limite de la sous-suite de \lean{y} puisque elle coincide avec cette dernière.

Rappelons que \lean{closure_closed_is_closed} nous donne l'égalité de tous fermé avec son adhérence. Donc \lean{l} est dans \lean{H}.

Finalement \lean{f} et \lean{l} sont de bons candidats pour obtenir une sous-suite de \lean{x} convergente dans \lean{H}.

Il reste à montrer que cette sous-suite converge bien vers \lean{l}. On utilise alors la définition de \lean{y} pour obtenir l'égalité \lean{eg}. Puis nous obtenons la convergence par une preuve en $\epsilon$. \lean{Function.comp_apply} justifie que pour toute fonction $u$, $v$ et pour tout $x$, $(u \circ v) (x) = u(v(x)) $ \\

De façon similaire la preuve suivante montre que toute partie fermée d'un espace compact est compact. Nous adaptons donc la preuve précédente, pour l'hypothèse que \lean{X} est compact.

\begin{minted}{lean}
lemma closed_incompact_iscompact (hX : Compact X) ( K :  Set X) (hK : is_closed K) : is_compact K := by
  intro x
  let x' : ℕ → X := λ n ↦ x n
  obtain ⟨ f, l, hf,limite⟩ := hX x'
  use f 
  have eg : ∀ n , x n = x' n:= by
    intro n
    rfl
  have limite2 : lim (x ∘ f) l := by
    intro ε hε 
    obtain ⟨ N , hN⟩ := limite ε hε 
    use N 
    intro n hn
    specialize hN n hn
    rw [Function.comp_apply]
    rw [Function.comp_apply] at hN
    rw [eg]
    exact hN
  have hl :l ∈ Closure K  := (sequential_closure K l).mpr ⟨ x∘f ,limite2⟩ 
  rw [closure_closed_is_closed hK] at hl
  use l
\end{minted}


\subsubsection{Compacité et continuité}

L'image d'un compact par une fonction continue est compact. En voici la preuve formalisée en lean.

\begin{minted} {lean}
lemma image_continuous_compact (f : X → Y ) (f_continuous: Continuous f) (h_compact : Compact  X) : is_compact (Set.image f Set.univ) := by

  intro y
  have hn : ∀ n, ∃ xn ∈ Set.univ, f (xn ) = y n := by
    intro n
    exact ( (Set.mem_image f Set.univ ( y n)).mp (y n).2 )

  choose x hx using hn
  obtain ⟨ j, l, croiss_j,lim_in_univ⟩ := h_compact x
  use j, (f l) 

  have hf :  f l ∈ f '' Set.univ := by   
    apply (Set.mem_image f Set.univ ( f l)).mpr
    use l
    apply And.intro
    exact Set.mem_univ l
    rfl
    
  apply And.intro
  exact hf 
  apply And.intro
  exact croiss_j

  have limite : lim' (f ∘ x ∘ j) (f l) := by -- d'abord on doit montrer lim' car f prend ses antécédents dans X
    apply ( sequential_continous f l).mp (f_continuous  l ) (x∘j)
    intro ε hε 
    obtain ⟨ N, hN ⟩ := lim_in_univ ε hε
    use N 

  intro ε hε
  obtain ⟨ N, hN ⟩ :=  limite ε hε
  use N
  intro n hn
  rw [Function.comp_apply]
  rw [←  (hx (j n)).2]
  specialize hN n hn
  rw [ Function.comp_apply] at hN 
  exact hN

\end{minted}

Dans cette preuve \lean{Set.univ} désigne l'ensemble des éléments de \lean{X} et est un type de \lean{Set X}. \lean{Set.image} désigne l'image par \lean{f} d'un type de \lean{Set X}. Donc \lean{Set.image} ne peux pas prendre \lean{X} en argument. On prendra donc l'image de \lean{Set.univ}.

Comme précédemment, nous montrons qu'un ensemble est compact en introduisant une suite, il faut alors construire une sous suite qui converge dans cette ensemble. Ici l'ensemble est \lean{(Set.image f Set.univ}, ainsi par définition de l'image direct, nous construisons d'abord la suite \lean{x}.

La tactique \lean{obtain} introduit une sous suite de \lean{x} convergente, dont l'existence est déduite de \lean{h_compact x}.

La tactique \lean{use} propose \lean{j} pour extraire une sous suite de \lean{y} par composition et \lean{f l} pour la limite de cette sous suite. Le but se réduit à vérifier que \lean{j} et \lean{f l} sont de bons candidats.

On montre que \lean{f l} est dans \lean{(Set.image f Set.univ}. Cette propriétée est vrai pour tout élément de \lean{X}. 

avant d'appliquer cette propriétée, \lean{apply And.intro} permet de séparer les arguments du but \lean{ ⊢ f l ∈ f '' Set.univ ∧ strictement_croissante j ∧ lim (y ∘ j) (f l)}. On fait de même pour appliquer la stricte croissance de \lean{j}. 

Enfin, la convergence de la sous-suite de \lean{y} est obtenu par continuité de \lean{f} en écrivant \lean{y} comme la composée de \lean{f} par \lean{x}. Cependant, \lean{limite} est prouvé pour \lean{lim'} car la sous-suite écrite sous cette forme est à valeur dans \lean{Y}. Or nous voulons qu'elle converge dans \lean{Set.image f Set.univ} de type \lean{Set Y}.

Ainsi, on montre que \lean{lim} coincide trivialement avec \lean{lim'} par une preuve en epsilon.

\subsubsection{Compacité et complétude}

Tout espace métrique compact est complet. Ceci est la dernière proposition de base que nous avons formalisé en Lean avant de définir la compacité de manière topologique.

\begin{minted} {lean}
lemma compact_is_complet (K : Type v) [MetricSpace K] : Compact K -> Complet K := by
  intro h x hx 
  obtain ⟨ f, l, hf,lim_l⟩ := h x  
  use l
  apply Cauchy_val_adherence_conv x l f hf lim_l hx 
\end{minted}

La preuve est simple. Il suffit d'introduire une suite \lean{x} de Cauchy. Comme \lean{K} est compact (\lean{h}), \lean{x} admet une sous-suite qui converge. On introduit cette sous-suite ainsi que sa limite nommée \lean{l} par la tactique \lean{obtain}. On propose \lean{l} comme candidat de la limite de \lean{x}. Enfin, ceci est vérifié par le lemme \lean{Cauchy_val_adherence_conv} démontré dans la section Complétude.


\subsubsection{Compacité et recouvrements}

\subsection{Connexité}

\newpage

\nocite{*}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
