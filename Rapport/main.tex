%! TeX program = lualatex
\documentclass[a4paper, 12pt]{article}

\usepackage{fontspec}
\usepackage{multicol}
\usepackage[french]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{enumitem}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{wrapfig}
\usepackage[french]{datetime}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{array}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{newunicodechar}
\usepackage{emoji}

% Required for UTF-8 characters in minted env
\setmonofont{FiraCode}

\usemintedstyle{tango}
\setminted[lean]{linenos, breaklines, fontsize=\footnotesize}
\setminted[Lean]{breaklines, fontsize=\footnotesize} % For tabular
\setminted[haskell]{linenos, fontsize=\footnotesize}
\newcommand{\lean}[1]{\mintinline[breaklines]{lean}{#1}}
\newcommand{\haskell}[1]{\mintinline{haskell}{#1}}

\newunicodechar{‚àò}{\circ}
\newunicodechar{‚ñ∏}{\blacktriangleright}
\newunicodechar{‚Ü¶}{\mapsto}
\newunicodechar{·∂ú}{\textsuperscript{c}}
\newunicodechar{·µâ}{\textsuperscript{e}}
\newunicodechar{·µ§}{\textsubscript{u}}
\newunicodechar{·µ•}{\textsubscript{v}}
\newunicodechar{‚ãÇ}{\ensuremath{\bigcap}}
\newunicodechar{‚ãÉ}{\ensuremath{\bigcup}}
\newunicodechar{üéâ}{\emoji{party-popper}}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    pdftitle={D√©monstration assist√©e par ordinateur},
}

\urlstyle{same}

\begin{document}

\begin{titlepage}

    \begin{figure}
        \centering
        % \includegraphics[width=8cm]{logo.png} % Logo Sorbonne
        \vspace{8cm}
    \end{figure}

    \vspace{6cm}

    \begin{center}
        {\Huge D√©monstration assist√©e par ordinateur\\}
        \vspace{0.5cm}
        {\huge Rapport final\\}

        \vspace{1.5cm}

        {\large Luc Saccoccio--Le Guennec\\ Nour Bouabid\\ Charles De Vergeron}
        \vfill
        {\large \today}
        \pagebreak
    \end{center}

\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}

\subsection{Assistants de preuves}

Un assistant de preuve est un logiciel permettant l'√©criture d'√©nonc√©s logiques et la v√©rification de preuves formelles. Il existe de nombreux assistants de preuves, parmi lesquels on peux citer :

\begin{itemize}
    \item Coq, d√©velopp√© en OCaml par l'√©quipe \href{http://www.pps.univ-paris-diderot.fr/pi.r2/}{PI.R2}
    \item Isabelle, d√©velopp√© en Standard ML et Scala
    \item Agda, d√©velopp√© en Haskell
\end{itemize}

On peut noter qu'ils diff√®rent sur de nombreux points. En prenant Coq comme standard :

\begin{itemize}
    \item Isabelle n'est pas en capacit√© de raisonner avec des types d√©pendants
    \item Agda ne dispose pas de m√©canismes d'automatisation de preuves
\end{itemize}

Qui plus est, il existe des langages de programmation dont le syst√®me de types permet la formalisation de certains √©nonc√©s, comme Haskell; ou n'ayant pas pour objectif de permettre la formalisation d'√©nonc√©s math√©matiques mais plut√¥t la v√©rification de programmes informatiques, comme F*.

Le fonctionnement des assistants de preuves, autrement dit ce qui permet de s'assurer que l'assistant comprend bien les √©nonc√©s que nous encodons et qu'il a en effet raison lorsqu'il affirme que notre preuve est (ou n'est pas) acceptable; repose sur la, ou plut√¥t une th√©orie des types.

\subsection{Petit historique}

Ce qui suit est un historique extr√™mement concis et r√©ducteur de plus de 2 000 ans d'histoire d'une certaine branche de la logique.

L'histoire de la formalisation des math√©matiques commence avec Aristote et l'introduction de la m√©thode axiomatique et de r√®gles logiques. Apr√®s de nombreuses p√©rip√©ties, on peut consid√©rer que ces objectifs furent atteint par Frege pour la logique classique, et par Heyting pour la logique intuitionniste. Cette consid√©ration est n√©anmoins discutable, et en 1910 Whitehead et Russell introduisirent la notion de type pour y rem√©dier dans les volumineux \textit{Principia Mathematica}. Malgr√© son efficacit√© √† r√©soudre les probl√®mes ayant motiv√© sa cr√©ation, c'est √† dire les paradoxes de la th√©orie na√Øve des ensembles de Frege, cette th√©orie √©tait assez rigide et ne formalisait pas le m√©canisme de substitution. C'est avec le $\lambda$-calcul d'Alonzo Church en 1940 que ce m√©canisme est formalis√©, et il cr√©e la th√©orie des types simples. En 1934 puis en 1958, Haskell Curry remarque qu'il y a une forme de correspondance entre les types et les sch√©mas d'axiomes intuitionnistes, puis de m√™me entre certains mod√®les de preuves et certains mod√®les de calcul. Enfin, en 1969, William Alvin Howard observe que la d√©duction naturelle peut s'interpr√©ter comme sa version intuitionniste vu comme une version typ√©e du $\lambda$-calcul :

\begin{center}
    Il y a un isomorphisme entre les $\lambda$-termes et les preuves, et entre leurs types et les √©nonc√©s logiques.
\end{center}

C'est la correspondance de Curry-Howard(-Lambek pour la version cat√©goriste)

Dans les ann√©es 70, de Bruijn √©tend le syst√®me de types en introduisant les types d√©pendants avec pour objectif affich√© de formaliser et v√©rifier les math√©matiques. Il cr√©e alors le premier assistant de preuve, \textbf{AUTOMATH}. En 1973, un autre assistant de preuve, Mizar, est d√©velopp√©, mais sur des bases ensemblistes (en particulier la th√©orie des ensembles de Tarski-Grothendieck). Il est publi√© en 1989. Mais √† partir des ann√©es 80, il y a une explosion de la recherche en ce domaine, avec Per Martin-L√∂f, Girard et Barendregt...

L'histoire est parcell√©e de p√©rip√©ties, mais nous finirons cet historique en 2004 avec la formalisation en Coq du th√©or√®me des quatres couleurs. Bien que ce r√©sultat fut prouv√© maintes fois (en 1976 par Appel et Haken, 1996, 1997...) y compris sur des assistants de preuves, la formalisation en Coq r√©duit d'une part les programmes √† un seul : le noyau de Coq, et d'autre part automatise les tr√®s nombreux configurations √† prendre en compte.

\subsection{Ce projet}

Ce projet a pour but d'impl√©menter une partie de notre cours de topologie m√©trique (LU3MA260) dans l'assistance de preuve \href{https://lean-lang.org/}{Lean}. Cela implique donc de commencer par d√©finir les objets √©tudi√©s (espaces m√©triques, boules, applications continues...) puis d'encoder et de v√©rifier nos th√©or√®mes et preuves.

\newpage
\section{Lean}

Pour ce projet, nous utiliserons l'assistant de preuves Lean (version 4.5.0 lors de l'√©criture de ce rapport). Il y a plusieurs raisons pour ce choix parmi lesquelles :
\begin{itemize}
    \item L'environnement de d√©veloppement interactif
    \item Le support natif des caract√®res unicode
    \item Les capacit√©s de m√©ta programmation
\end{itemize}

Outre, bien entendu, son utilisation dans D$\exists\forall$DUCTION \cite{deaduction}, sa simplicit√© d'apprentissage, la documentation (\cite{theorem_proving}, \cite{math_in_lean}) et la communaut√© Lean sur Zulip pouvant r√©pondre √† nos interrogations.

Nous utilisons essentiellement Mathlib, une librairie contenant un vaste ensemble de r√©sultats math√©matiques, pour des structures usuelles comme les r√©els ainsi que pour conclure des preuves n√©cessitant la manipulation d'in√©galit√©s, cela n'√©tait pas tr√®s int√©ressant.

\subsection{Histoire}

Lean est un langage open-source d√©velopp√© depuis 2013 bas√© sur le calcul des constructions (la version du lambda-calcul la plus "forte" selon la classification de Barendregt \cite{Barendregt_1991}), tout comme Coq. Bien que les premiers essais aient contenus des fondations alternatives (notamment la th√©orie homotopique des types), en 2017 sort Lean 3, la premi√®re version stable impl√©ment√©e majoritairement en C++. En 2021 commence Lean 4, une r√©impl√©mentation de Lean majoritairement en Lean avec certaines parties en C++. Cette version contient en outre un syst√®me de macros extr√™mement puissant qui permet d'impl√©menter et de modifier un ensembles de composants du frontend en Lean plut√¥t qu'en C++.

\subsection{Cycle de d√©veloppement}

\subsubsection{Arborescence}

Un projet Lean commence par la cr√©ation d'un dossier d√©di√© √† l'aide du programme \lean{lake}. On peut alors pr√©ciser que l'on compte utiliser Mathlib dans le fichier \lean{lakefile.lean}. Ensuite on peut commencer √† programmer ou prouver des r√©sultats. Seul le second cas nous int√©resse. L'arborescence d'un projet Lean consiste en un unique dossier portant le nom du projet, lequel contient un ensemble de dossiers et de fichiers Lean. L'arborescence d'un projet est un premier outil pour structurer un ensemble de r√©sultats, on choisit de diviser les r√©sultats en plusieurs fichiers et dossiers suivant le plus souvent les champs ou les domaines plus sp√©cifiques auxquels ils appartiennent. Par exemple, si on souhaitait √©laborer la topologie depuis les axiomes ensemblistes, on devrait d√©velopper un ensembles de lemmes accessoires en logique (n'√©tant pas dans la biblioth√®que standard), les bases de la th√©orie des ensembles et enfin les bases de la topologie g√©n√©rale (en oubliant la construction des ensembles usuels), une arborescence possible serait :

\newpage
\begin{minted}{text}
Project
‚îú‚îÄ‚îÄ Logic
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Basic.lean
‚îú‚îÄ‚îÄ Set
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Basic.lean
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Functions.lean
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Indexed.lean
‚îî‚îÄ‚îÄ Topology
    ‚îú‚îÄ‚îÄ Basic.lean
    ‚îú‚îÄ‚îÄ Separation
    ‚îÇ   ‚îî‚îÄ‚îÄ Basic.lean
    ‚îú‚îÄ‚îÄ Compactness
    ‚îÇ   ‚îî‚îÄ‚îÄ Basic.lean
    ...
\end{minted}

\subsubsection{Structure d'un fichier}

Un fichier Lean suit le plus souvent une certaine structure :

\begin{minted}{lean}
import ...

universe ...

variable ...

...

section ...

end ...
\end{minted}

Tout d'abord, les importations de fichiers. L'id√©e est la m√™me qu'un \mintinline[fontsize=\footnotesize]{python}{import} en Python ou \mintinline[fontsize=\footnotesize]{c}{#include} en C, cette commande importe l'ensemble des r√©sultats du fichier voulue dans le fichier dans lequel se trouve la commande. Le nom du fichier √† importer correspond √† son chemin dans l'arborescence. Pour reprendre l'arborescence ci-dessus, on peut par exemple importer les r√©sultat en logique avec \lean{import Project.Logic.Basic}.

On d√©clare ensuite un ensemble d'\textit{univers}. Un univers est un type qui classifie un ensemble de types. Les plus communs sont \lean{Type} et \lean{Prop}, le premier classifiant un ensemble de types "ordinaires", comme \lean{Nat}, \lean{String} ou \lean{Int ‚Üí Nat}, et le second classifiant des propositions, comme \lean{2 = 3} et \lean{‚àÄ x y z : ‚Ñï, (x * y) * z = x * (y * z)}. Or il existe de nombreux autres univers puisque par exemple, \lean{Type} n'est classifi√© ni par \lean{Prop}, ni par lui m√™me. En effet, dans les versions de la th√©orie des types d√©pendants dans lesquelles il est possible d'assigner \lean{Type} comme type √† \lean{Type}, on aboutit √† la construction d'un terme de type \lean{‚àÄ p : *, p} qui par la correspondance de Curry-Howard, signifie que toute proposition est d√©montrable, rendant la th√©orie inconsistante. Cette contradiction est nomm√©e paradoxe de Girard \cite{coquand}, et c'est l'√©quivalent en th√©orie des types du paradoxe de Russell en th√©orie des ensembles. Il existe donc une classification des univers avec des entiers naturels : \lean{Type} est de type \lean{Type 1}, qui lui m√™me est de type \lean{Type 2}, et ainsi de suite. Le type d'une fonction est donc l'univers le plus petit dans lequel tout ses arguments existent : \lean{Nat ‚Üí Nat} a pour type \lean{Type} et \lean{Type 3 ‚Üí Type 5} a pour type \lean{Type 6}, √† l'exception des fonctions ayant pour type de retour \lean{Prop} qui sont toujours de type \lean{Prop}. D√©clarer un univers signifie donc choisir un univers quelconque et d√©montrer l'ensemble des r√©sultats au sein de cet univers. Cela permet de g√©n√©raliser un grand nombre de r√©sultats ind√©pendamment de l'univers choisi.

On peut aussi d√©clarer un ensemble de variables avec \lean{variable}. C'est √©quivalent en math√©matiques √† dire "On se donne ...". Il est possible d'ajouter des instances de classe aux types choisis, par exemple pour un mono√Øde :

\begin{minted}{lean}
variable {M : Type u} [Monoid M]
\end{minted}

On peut alors commencer √† √©noncer des d√©finitions, des r√©sultats et les d√©montrer. On peut aussi d√©finir une \lean{section} (potentiellement anonyme), c'est √† dire un ensemble du fichier dans lequel on pourra d√©finir d'autres variables et univers qui n'existeront qu'au sein de cette section, et que l'on devra r√©f√©rencer avec \lean{Name.resultat} avec \lean{Name} le nom de la section et \lean{resultat} l'objet voulu, ou en "ouvrant" la section pr√©alablement avec \lean{open Name}.

\subsubsection{√ânonc√©s et preuves}

Un √©nonc√© est un terme de type \lean{Prop}. Par exemple :

\begin{minted}{lean}
def Even (n : ‚Ñï) : Prop := ‚àÉ m : ‚Ñï, n = 2 * m
\end{minted}

On peut d√©finir des th√©or√®mes, lemmes et exemples avec \lean{theorem}, \lean{lemma}, \lean{example}. Chaque th√©or√®me ou lemme a un nom, un type (la proposition) et une preuve :

\begin{minted}{lean}
theorem even_even : ‚àÄ n : ‚Ñï, Even (n + n) := sorry
\end{minted}

Chaque preuve a un but, c'est √† dire la proposition √† prouver, et un contexte : l'ensemble des hypoth√®ses de la preuve. Le contexte ne contient pas les autres r√©sultats du fichier, qui sont n√©anmoins utilisables. L'√©quivalent math√©matique du contexte correspond √† l'ensemble des hypoth√®ses faites et des variables d√©finis ("On prend ...", "On se donne ..."). Bien que certaines preuves puissent √™tre faites sans rentrer dans un contexte de preuves (dans les cas o√π le r√©sultat est une conclusion d'un autre th√©or√®me par exemple), la majorit√© des preuves commencent par \lean{by} qui permet de cr√©er un contexte et d'entrer dans un environnement de preuves. On utilise ensuite un ensemble de tactiques et de r√©sultats pr√©c√©dents pour prouver le but.

√âtudions quelques exemples de preuves pour comprendre comment en mener une. √Ä gauche figurera l'√©volution du code de la preuve, et √† droite l'√©volution du contexte (qui s'affiche dans l'√©diteur et donne l'avancement de la preuve √† l'endroit o√π se trouve le curseur).

\begin{tabular}{m{0.5\textwidth} | m{0.5\textwidth}}
    \begin{minipage}[t]{0.5\textwidth}
    \begin{minted}{Lean}
example (p q : Prop) (hp : p) (hq : q) : p ‚àß q := by
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.5\textwidth}
    \begin{minted}{Lean}
p q : Prop
hp : p
hq : q
‚ä¢ p ‚àß q
    \end{minted}
    \end{minipage}
    \\\hline

    \begin{minipage}{0.5\textwidth}
    \begin{minted}{Lean}
example (p q : Prop) (hp : p) (hq : q) : p ‚àß q := by
  constructor
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.5\textwidth}
    \begin{minted}{Lean}
‚ñ∂ 2 goals
case left
p q : Prop
hp : p
hq : q
‚ä¢ p

case right
p q : Prop
hp : p
hq : q
‚ä¢ q
    \end{minted}
    \end{minipage}
    \\\hline
    \begin{minipage}[t]{0.5\textwidth}
    \begin{minted}{Lean}
example (p q : Prop) (hp : p) (hq : q) : p ‚àß q := by
  constructor
  . exact hp
  . exact hq
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.5\textwidth}
    \begin{minted}{Lean}
‚ñ∂ goals accomplished üéâ
    \end{minted}
    \end{minipage}
\end{tabular}
\vspace{\baselineskip}

On voit donc que \lean{constructor} a introduit deux sous-buts, ayant chacun son propre contexte, et que l'on prouve s√©par√©ment. On use du point pour s√©parer syntaxiquement les deux preuves des sous-buts, afin d'am√©liorer la lisibilit√© du code, mais ils ne sont pas n√©cessaires pour Lean. Chaque sous-but est cl√¥t avec une hypoth√®se du contexte, √† l'aide de la tactique \lean{exact}.

\vspace{\baselineskip}
\begin{tabular}{m{0.6\textwidth} | m{0.4\textwidth}}
    \begin{minipage}[t]{0.6\textwidth}
    \begin{minted}{Lean}
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.4\textwidth}
    \begin{minted}{Lean}
‚ä¢ ‚àÄ (a b c : Nat), a = b ‚Üí a = c ‚Üí c = b
    \end{minted}
    \end{minipage}
    \\\hline
    \begin{minipage}[t]{0.6\textwidth}
    \begin{minted}{Lean}
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
  intro a b c h‚ÇÅ h‚ÇÇ
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.4\textwidth}
    \begin{minted}{Lean}
a b c : Nat
h‚ÇÅ : a = b
h‚ÇÇ : a = c
‚ä¢ c = b
    \end{minted}
    \end{minipage}
    \\\hline
    \begin{minipage}[t]{0.6\textwidth}
    \begin{minted}{Lean}
example : ‚àÄ a b c : Nat, a = b ‚Üí a = c ‚Üí c = b := by
  intro a b c h‚ÇÅ h‚ÇÇ
  exact Eq.trans (Eq.symm h‚ÇÇ) h‚ÇÅ
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.4\textwidth}
    \begin{minted}{Lean}
‚ñ∂ goals accomplished üéâ
    \end{minted}
    \end{minipage}
\end{tabular}
\vspace{\baselineskip}

On voit ici l'utilisation de la tactique \lean{intro}, qui introduit des hypoth√®ses dans le contexte, en les nommant respectivement. On finit enfin avec un exemple de la tactique \lean{rw} qui r√©√©crit le but √† l'aide d'hypoth√®ses du contexte.

\vspace{\baselineskip}
\begin{tabular}{m{0.65\textwidth} | m{0.35\textwidth}}
    \begin{minipage}[t]{0.65\textwidth}
    \begin{minted}{Lean}
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{Lean}
f : Nat ‚Üí Nat
k : Nat
h‚ÇÅ : f 0 = 0
h‚ÇÇ : k = 0
‚ä¢ f k = 0
    \end{minted}
    \end{minipage}
    \\\hline
    \begin{minipage}[t]{0.65\textwidth}
    \begin{minted}{Lean}
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
  rw [h‚ÇÇ]
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{Lean}
f : Nat ‚Üí Nat
k : Nat
h‚ÇÅ : f 0 = 0
h‚ÇÇ : k = 0
‚ä¢ f 0 = 0
    \end{minted}
    \end{minipage}
    \\\hline
    \begin{minipage}[t]{0.65\textwidth}
    \begin{minted}{Lean}
example (f : Nat ‚Üí Nat) (k : Nat) (h‚ÇÅ : f 0 = 0) (h‚ÇÇ : k = 0) : f k = 0 := by
  rw [h‚ÇÇ]
  rw [h‚ÇÅ]
    \end{minted}
    \end{minipage}
    &
    \begin{minipage}[t]{0.35\textwidth}
    \begin{minted}{Lean}
‚ñ∂ goals accomplished üéâ
    \end{minted}
    \end{minipage}
\end{tabular}
\vspace{\baselineskip}

\subsection{M√©ta programmation}

La capacit√© pour Lean d'utiliser des caract√®res Unicode repose sur l'introduction de syntaxe. Mais Lean est en r√©alit√© bien plus puissant. Bien que les m√©canismes internes sur lesquels reposent l'ensemble des fonctionnalit√©s de m√©ta programmation soient trop complexe pour ce document, on pourra se r√©f√©rer au livre \cite{meta_lean}. Nous allons n√©anmoins examiner deux exemples de m√©ta programmation en Lean (sans pour autant en explorer les technicit√©s).

\subsubsection{Notations}

Introduire une notation permet d'√©crire en Lean des math√©matiques comme on les √©crirait sur papier. Ainsi, une union d'ensembles $\bigcup$, une somme index√©e $\Sigma$, ou m√™me une boule ouverte centr√©e en $x$ d'un rayon $r$ $B(x, r)$; sont des notations qui ne sont pas natives en Lean, mais que l'on construit √† l'aide des outils de m√©ta programmation fournis. Il y a deux √©tapes : introduire une syntaxe puis une s√©mantique. Autrement dit, il faut d'abord indiquer quel pattern doit √™tre cherch√©, pour en suite exprimer ce qu'il signifie. Un exemple simple :

\begin{minted}{lean}
macro x:ident ":" t:term " ‚Ü¶ " y:term : term => do `(fun $x : $t => $y)
\end{minted}

Ainsi l'expression \lean{x : ‚Ñï ‚Ü¶ 2 * x} devient gr√¢ce √† cette macro \lean{fun x : ‚Ñï => 2 * x}. \lean{x} est un identifiant, \lean{t} est un type (on utilise \lean{term} pour reconnaitre un terme au sens g√©n√©ral) et \lean{y} est une expression (√©ventuellement contenant l'identifiant \lean{x}). On remarque que la syntaxe et la s√©mantique sont introduites en une seule commande, \lean{macro}. Un autre exemple pour introduire des notations ensemblistes :

\begin{minted}{lean}
open Std.ExtendedBinder in
syntax "{" extBinder " | " term "}" : term

macro_rules
  | `({ $x:ident | $p }) => `(setFrom (fun $x:ident => $p))
  | `({ $x:ident : $t | $p }) => `(setFrom (fun $x:ident : $t => $p))
  | `({ $x:ident $b:binderPred | $p }) => `(setFrom (fun $x:ident => satisfies_binder_pred% $x $b ‚àß $p))

open Std.ExtendedBinder in
macro (priority := low) "{" t:term " | " bs:extBinders "}" : term =>
  `({x | ‚àÉ·µâ $bs:extBinders, $t = x})
\end{minted}

On introduit ici une syntaxe g√©n√©rale \lean{"{" extBinder " | " term "}"}, et selon la forme du premier terme, on associe une s√©mantique particuli√®re √† chaque cas :
\begin{itemize}
    \item \lean{{ $x:ident | $p }}, c'est le sch√©ma de compr√©hension classique $\{x\ \mid\ p(x)\}$.
    \item \lean{{ $x:ident : $t | $p}}, on traite ici le cas avec une annotation de type.
    \item \lean{{ $x:ident $b:binderPred | $p }}, c'est le sch√©ma de compr√©hension $\{p(x)\ \mid\ q(x)\}$. Il est interpr√©t√© comme $\{x\ \mid\ p(x)\land q(x)\}$
\end{itemize}

On ajoute √† cela le cas plus rare $\{f(x)\ \mid\ x\ :\ X\}$ avec l'option \lean{priority := low} pour souligner que ce cas doit √™tre trait√© apr√®s avoir tent√© les s√©mantiques pr√©c√©dentes, qui est √©quivalent √† $\{y\ \mid\ \exists x\ :\ X, y = f x\}$. On peut aussi mentionner les union et intersection ensemblistes index√©es par un ensemble :

\begin{minted}{lean}
open Std.ExtendedBinder in
syntax "‚ãÇ (" extBinder "), " term:60 : term

macro_rules
  | `(‚ãÇ ($x:ident : $t), $p) => `(iInter (fun $x:ident : $t => $p))

open Std.ExtendedBinder in
syntax "‚ãÉ (" extBinder "), " term:60 : term

macro_rules
  | `(‚ãÉ ($x:ident : $t), $p) => `(iUnion (fun $x:ident : $t => $p))
\end{minted}

Le principe est le m√™me, on introduit une syntaxe puis on explicite la s√©mantique. Il y a n√©anmoins une nuance suppl√©mentaire. Dans les sch√©mas de compr√©hension d'un ensemble, il n'y a pas d'ambig√ºit√© possible lors de la reconnaissance du pattern, puisque la syntaxe est "born√©e" par les caract√®res \lean{\{} et \lean{\}}, or dans le cas pr√©sent il n'y a pas de d√©limitation √† droite. C'est pourquoi on pr√©cise la priorit√© de l'op√©rateur (qui permet de d√©finir la priorit√© des op√©rations, operator precedence pour le terme anglais) avec \lean{term:60}. Une analogie en math√©matique est la priorit√© de $\times$ sur $+$ ($\times$ a un ordre sup√©rieur √† $+$). √Ä noter que les commandes \lean{notation} (et ses cas plus sp√©cifiques \lean{infix}, \lean{infixl}, \lean{infixr} et \lean{prefix}) supportent aussi l'ajout du suffixe \lean{:n} avec \lean{n} l'ordre de la priorit√©. Ainsi, il n'y a pas d'ambig√ºit√© possible et on peut choisir (en ayant connaissance de l'ordre des op√©rations usuelles, comme l'application de fonctions ou \lean{‚àß}) ce qui est reconnu par cette syntaxe.

Il devient alors possible d'√©crire \lean{‚ãÉ (i : Œπ), s i} pour $\bigcup_{i\in\iota} S_i$ (puisqu'une famille d'ensembles index√©s par $\iota$ est une fonction de $\iota$ dans les parties de l'union de tout les ensembles consid√©r√©s) et d'utiliser les notations \lean{{2*n | n : ‚Ñï}} ou \lean{‚ãÉ(n : ‚Ñï), {n}} (et elles ont bien le sens voulu).

\subsubsection{Tactiques}

Les tactiques sont l'autre force de Lean. Une tactique est un m√©canisme d'automatisation d'un certain nombre d'√©tapes de la preuve. Parmi les tactiques usuelles, on peut citer :
\begin{itemize}
    \item \lean{intro} : Elle introduit une ou plusieurs hypoth√®ses dans le contexte (potentiellement avec un nom), et modifie le but pour enlever les hypoth√®ses dans la cha√Æne d'implications.
    \item \lean{use} : Utilis√©e pour prouver un but du type \lean{‚àÉx, p x}, elle fixe \lean{x} et modifie le but en \lean{p x}.
    \item \lean{exact} : Cl√¥t un but avec une preuve ayant cette conclusion.
    \item \lean{have} : Nomme un r√©sultat interm√©diaire, qui doit n√©anmoins √™tre prouv√©.
    \item \lean{assumption} : Cl√¥t un but avec une hypoth√®se du contexte
    \item \lean{constructor} : Applique un constructeur ("ou" logique, "et" logique, double implication...) et cr√©e un ensemble de buts correspondants
    \item \lean{sorry} : Cl√¥t un but sans le prouver.
\end{itemize}

La tactique \lean{sorry} ne prouve rien en tant que tel, elle marque juste la preuve comme termin√© et utilisant l'instruction \lean{sorry}. Cela √©vite des erreurs lors de la v√©rification mais pr√©vient n√©anmoins l'utilisateur que la preuve n'est pas termin√©e.

Il y a un ensemble de tactiques qui peuvent √™tre utilis√©es sur des hypoth√®ses pr√©cises en place du but :
\begin{itemize}
    \item \lean{apply} : Applique une propri√©t√© au but (peut introduire des buts secondaires).
    \item \lean{rw} : R√©√©crit le but avec un ou plusieurs r√©sultats de la forme \lean{a = b} ou \lean{a ‚Üî b}.
    \item \lean{simp} : Simplifie(au sens large) une expression avec un ensemble de propositions choisies augment√© d'un ensemble de propositions fournies par l'utilisateur.
\end{itemize}

Par d√©faut seul le but est modifi√©, mais on peut pr√©ciser une hypoth√®se, un ensemble d'hypoth√®ses ou toutes les hypoth√®ses, ainsi que le but; que la tactique modifiera avec le suffixe \lean{at h}, \lean{at [h1, h2]}, \lean{at *} respectivement.

\vspace{\baselineskip}
Une tactique est une macro ou une commande de type \lean{tactic}. Pour les cas les plus simples, une macro suffit. Par exemple, une tactique r√©solvant les cas triviaux d'√©galit√©s avec plusieurs constructeurs logiques pourrait √™tre :

\begin{minted}{lean}
syntax "custom_trivial" : tactic

macro_rules
| `(tactic| custom_trivial) => `(tactic| constructor <;> custom_trivial)

example : 42 = 42 ‚à® 1 + 1 = 2 ‚àß 2 ^ 2 = 2 * 2 := by custom_trivial
\end{minted}

O√π \lean{<;>} est un op√©rateur de tactiques tel que \lean{a <;> b} applique \lean{a}, puis applique \lean{b} √† tout les buts g√©n√©r√©s par \lean{a}. Les tactiques plus complexe, demandant par exemple d'agir directement sur le contexte ou la liste de buts doivent √™tre √©crites avec \lean{elab}. Nous reproduisons ici un exemple\footnote{L'essentiel est de comprendre \textit{l'id√©e} plut√¥t que le code. Les pr√©requis n√©cessaires sont d√©taill√©s dans le livre cit√©. Pour le lecteur int√©ress√©, le code est n√©anmoins expliqu√© de fa√ßon plus d√©taill√©e en annexe.} tir√© de Metaprogramming in Lean 4 \cite{meta_lean} :

\begin{listing}[H]
    \begin{minted}{lean}
elab "custom_assump" : tactic =>
  Lean.Elab.Tactic.withMainContext do
    let goal ‚ÜêLean.Elab.Tactic.getMainGoal
    let goalType ‚ÜêLean.Elab.Tactic.getMainTarget
    let ctx ‚ÜêLean.MonadLCtx.getLCtx
    let option_matching_expr ‚Üêctx.findDeclM? fun decl: Lean.LocalDecl => do
      let declExpr := decl.toExpr
      let declType ‚ÜêLean.Meta.inferType declExpr
      if ‚ÜêLean.Meta.isExprDefEq declType goalType
        then return Option.some declExpr
        else return Option.none
    match option_matching_expr with
    | some e => Lean.Elab.Tactic.closeMainGoal e
    | none =>
      Lean.Meta.throwTacticEx `custom_assump goal
        (m!"unable to find matching hypothesis of type ({goalType})")
    \end{minted}
    \label{code:custom_assump}
\end{listing}

Cette tactique reproduit la tactique \lean{assumption} qui cl√¥t un but avec une hypoth√®se ayant le m√™me type. Le principe est assez simple : la tactique r√©cup√®re le but pour obtenir son type, r√©cup√®re le contexte et it√®re √† travers chaque hypoth√®se pour en trouver une ayant le m√™me type que le but. Si c'est le cas, la tactique cl√¥t la preuve avec cette tactique, sinon elle pr√©vient l'utilisateur qu'aucune hypoth√®se du type voulu n'a √©t√© trouv√©e.

\newpage
\section{La topologie m√©trique en Lean}

\subsection{Contexte et mise en place}

Le cours de topologie LU3MA260\cite{topology_memo} est divis√© 5 parties et 2 appendices :

\begin{itemize}
    \item Espaces m√©triques
    \item Compl√©tude
    \item Compacit√©
    \item Connexit√©
    \item Espaces vectoriels norm√©s, espaces de Banach
    \item Appendice I : ensembles et applications
    \item Appendice II : quelques sch√©mas
\end{itemize}

Nous laisserons de c√¥t√© les appendices ainsi que les deux derni√®res sections sur la connexit√©, les espaces vectoriels norm√©s et les espaces de Banach.

\subsection{Espaces m√©triques}

\subsubsection{Premi√®res d√©finitions}

On commence par d√©finir un espace m√©trique. C'est une classe de types sur lesquels on peut d√©finir une "distance", c'est √† dire la donn√©e de l'application et des propri√©t√©s qu'elle v√©rifie :

\begin{minted}{lean}
class MetricSpace (Œ± : Type u) where
    dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù
    dist_pos : ‚àÄ {x y : Œ±}, 0 ‚â§ dist x y
    dist_sep : ‚àÄ {x y : Œ±}, dist x y = 0 ‚Üî x = y
    dist_symm : ‚àÄ {x y : Œ±}, dist x y = dist y x
    dist_triangle : ‚àÄ {x y z : Œ±}, dist x z ‚â§ dist x y + dist y z

variable {X : Type u} [MetricSpace X]
\end{minted}

La derni√®re instruction, \lean{variable}, permet de d√©finir dans le contexte (soit le fichier, soit la \lean{section} dans laquelle on se trouve) des variables. Ici, nous nous sommes donn√©s un type \lean{X} dans l'univers \lean{u}, ainsi qu'une instance de la classe \lean{MetricSpace} pour le type \lean{X}. En termes math√©matiques, nous nous sommes donn√©s un ensemble $X$ ainsi qu'une structure d'espace m√©trique sur $X$.

On d√©finit aussi, car cela sera utile d√®s que l'on manipulera plusieurs espaces m√©triques distincts, deux notations plus pratiques pour la distance :

\begin{minted}{lean}
notation "d" => dist
notation "d_[" Œ± "]" => @dist Œ±
\end{minted}

On d√©finit ensuite les boules ouvertes et on introduit la notation usuelle $B(x, r)$ pour la boule de rayon $r$ centr√©e en $x$. Le type \lean{Set X} est le type des ensembles √† valeurs dans \lean{X}.

\begin{minted}{lean}
def open_ball (x : X) (r : ‚Ñù) : Set X := {y | d x y < r}

notation "B(" x "," r ")" => open_ball x r
\end{minted}

Il est tr√®s pratique d'introduire un ensemble de lemmes relativement √©vidents qui faciliteront les preuves. Ils sont tous marqu√©s avec \lean{@[simp]}, ce qui indique √† Lean qu'il peut les utiliser lors de l'application des tactiques \lean{simp} :

\begin{minted}{lean}
@[simp]
lemma dist_sep_eq_zero (x : X) : d x x = 0 := dist_sep.mpr rfl

@[simp]
lemma mem_open_ball (x : X) (r : ‚Ñù) (y : X) : y ‚àà B(x, r) ‚Üî dist x y < r := Iff.rfl

@[simp]
lemma center_in_ball (x : X) (r : ‚Ñù) : r > 0 ‚Üí x ‚àà B(x, r) := by
  intro r_pos
  simp [open_ball]
  assumption
\end{minted}

Dans le premier lemme, il suffit de consid√©rer seulement l'une des implications de l'axiome \lean{dist_sep} en fournissant la preuve que \lean{x = x} avec \lean{rfl}. Le second repose essentiellement sur la d√©finition d'une boule ouverte et sur la d√©finition d'un ensemble en Lean. Enfin, le dernier lemme consiste en l'introduction de l'hypoth√®se de positivit√© de \lean{r}, puis la simplification de la condition d'appartenance √† l'aide des deux lemmes pr√©c√©dents (ce qui justifie l'usage de \lean{@[simp]}). Le but devient \lean{0 < r}, ce qui est vrai par hypoth√®se, d'o√π l'usage de la tactique \lean{assumption}.

On finit enfin par la d√©finition d'un ouvert. C'est un objet de type \lean{Prop}, autrement dit un √©nonc√© math√©matique, param√©tr√© par l'ouvert $U$.

\begin{minted}{lean}
def is_open (U : Set X) : Prop := ‚àÄ x ‚àà U, ‚àÉ r > 0, B(x, r) ‚äÜ U
\end{minted}

On peut alors montrer un premier r√©sultats, c'est √† dire que le boule ouverte est bien ouverte :

\begin{minted}{lean}
lemma open_ball_is_open : ‚àÄ x : X, ‚àÄ r > 0, is_open B(x, r) :=
  by
    intros x r _ y y_in
    set Œµ := r - d x y with hŒµ
    use Œµ
    constructor
    . simp [open_ball] at y_in
      linarith only [hŒµ, y_in]
    . intros z z_in
      rw [mem_open_ball] at *
      have p : d x z ‚â§ d x y + d y z := dist_triangle
      linarith only [p, z_in, y_in, hŒµ]
\end{minted}

Pour ce qui est de la preuve, elle suit le raisonnement suivant :

\begin{itemize}
    \item On introduit les variables \lean{x}, \lean{r}, \lean{y} et l'hypoth√®se \lean{y_in} que \lean{y} est dans la boule \lean{B(x, r)}.
    \item On d√©fini le bon \lean{Œµ} et l'hypoth√®se \lean{hŒµ} qui contient la d√©finition de \lean{Œµ}, et on l'utilise pour d√©montrer que la boule est ouverte.
    \item On prouve alors les deux buts :
        \begin{itemize}
            \item On montre que \lean{Œµ > 0} √† l'aide de la d√©finition de la boule ouverte et de \lean{linarith}
            \item On montre l'inclusion des boules √† l'aide de la d√©finition par la distance d'une boule et de l'in√©galit√© triangulaire, et on conclue avec \lean{linarith}
        \end{itemize}
\end{itemize}

On d√©montre ensuite trois lemmes qui prouvent que les ouverts d√©finis par les boules forment bien une topologie :

\begin{minted}{lean}
lemma union_open_is_open (I : Set (Set X)) : (‚àÄ U ‚àà I, is_open U) ‚Üí is_open (‚ãÉ‚ÇÄ I) :=
  by
    intro U_open x ‚ü®U, U_app_I, x_app_U‚ü©
    obtain ‚ü®r, r_pos, ball_in_U‚ü© : ‚àÉ r > 0, B(x, r) ‚äÜ U :=
      (U_open U) U_app_I x x_app_U
    use r, r_pos
    . exact Set.Subset.trans ball_in_U (Set.subset_sUnion_of_mem U_app_I)

lemma inter_open_is_open : ‚àÄ U V : Set X, is_open U ‚Üí is_open V ‚Üí is_open (U ‚à© V) :=
  by
    intro U V U_open V_open x ‚ü®x_in_U, x_in_V‚ü©
    obtain ‚ü®r·µ§, r·µ§_pos, ball_in_U‚ü© : ‚àÉ r·µ§ > 0, B(x, r·µ§) ‚äÜ U := U_open x x_in_U
    obtain ‚ü®r·µ•, r·µ•_pos, ball_in_V‚ü© : ‚àÉ r·µ• > 0, B(x, r·µ•) ‚äÜ V := V_open x x_in_V
    use min r·µ§ r·µ•, lt_min r·µ§_pos r·µ•_pos
    . intro y y_in_ball
      simp at y_in_ball
      apply And.intro
      . exact ball_in_U y_in_ball.left
      . exact ball_in_V y_in_ball.right

lemma space_open : is_open (Set.univ : Set X) :=
  fun x _ => ‚ü®1, (And.intro zero_lt_one (Set.subset_univ B(x, 1)))‚ü©
\end{minted}

Le premier montre que l'union d'un ensemble quelconque d'ouvert est ouvert. La preuve est imm√©diate, il suffit de prendre un √©l√©ment dans l'union et prendre la boule dans l'ouvert dans lequel se trouve l'√©l√©ment, avant de conclure par transitivit√© de $\subseteq$. Le second montre que l'intersection de deux ouvert est ouverte. Il faut alors prendre deux boules dans chacun des ouverts puis on prend la boule de rayon minimal. Il suffit alors de d√©montrer que cette boule est incluse dans chacun des ouverts, ce qui est imm√©diat. Enfin, on d√©montre que l'espace tout entier est ouvert en prenant une boule de rayon 1.

On d√©finit enfin l'int√©rieur d'un ensemble comme l'union des ouverts inclus, qui est donc ouvert par le lemme montr√© plus haut. On note l'utilisation de \lean{simp_all} qui √©vite d'√©crire \lean{(fun _ u_in => u_in.left)}.

\begin{minted}{lean}
def Interior (E : Set X) := ‚ãÉ‚ÇÄ {U : Set X | is_open U ‚àß U ‚äÜ E}
lemma interior_is_open {E : Set X} : is_open (Interior E) := union_open_is_open {U : Set X | is_open U ‚àß U ‚äÜ E} (by simp_all)
\end{minted}

On d√©montre enfin l'√©quivalence entre la d√©finition topologique et la d√©finition m√©trique de l'int√©rieur :

\begin{minted}{lean}
@[simp]
lemma metric_interior {E : Set X} {x : X} : x ‚àà Interior E ‚Üî ‚àÉ r > 0, B(x, r) ‚äÜ E :=
  by
    constructor
    . intro x_in_E
      rcases x_in_E with ‚ü®U, ‚ü®U_open, U_sub_E‚ü©, x_in_U‚ü©
      obtain ‚ü®r, r_pos, ball_in_U‚ü© : ‚àÉ r > 0, B(x, r) ‚äÜ U := U_open x x_in_U
      use r, r_pos
      trans U <;> assumption
    . rintro ‚ü®r, r_pos, ball_in_E‚ü©
      have ball_open : is_open B(x, r) := open_ball_is_open x r r_pos
      use B(x, r)
      simp_all
\end{minted}

On proc√®de par double implication, en se donnant un √©l√©ment de l'espace
\begin{itemize}
    \item Si l'√©l√©ment est dans l'int√©rieur, il est dans un ouvert inclus dans E, donc il existe une boule ouverte centr√©e en ce point, incluse dans l'ouvert. Or cet ouvert est inclus dans E donc par transitivit√©, la boule est dans E.
    \item S'il existe une boule centr√©e en l'√©l√©ment, puisqu'une boule est ouverte, la boule est dans l'int√©rieur, est l'√©l√©ment √©tant dans la boule, l'√©l√©ment est dans l'int√©rieur.
\end{itemize}

\subsubsection{Continuit√©}

On commence par d√©finir la continuit√© en un point, puis la continuit√© globale :

\begin{minted}{lean}
def continuous_on (f : X ‚Üí Y) (x‚ÇÄ : X) : Prop :=
  ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x, d_[X] x‚ÇÄ x < Œ¥ ‚Üí d_[Y] (f x‚ÇÄ) (f x) < Œµ

def Continuous (f : X ‚Üí Y) : Prop := ‚àÄ x : X, continuous_on f x
\end{minted}

On d√©montre ensuite l'√©quivalence entre la d√©finition m√©trique et la d√©finition topologique de la continuit√© :

\begin{minted}{lean}
theorem topologic_continuity (f : X ‚Üí Y) : Continuous f ‚Üî (‚àÄ U, is_open U ‚Üí is_open (f ‚Åª¬π' U)) :=
  by
    constructor
    . intro h U U_open x‚ÇÄ x‚ÇÄ_in_reci_f
      obtain ‚ü®Œµ, Œµ_pos, ball_in_U‚ü© : ‚àÉ Œµ > 0, B(f x‚ÇÄ, Œµ) ‚äÜ U := U_open (f x‚ÇÄ) x‚ÇÄ_in_reci_f
      rcases (h x‚ÇÄ) Œµ Œµ_pos with ‚ü®Œ¥, Œ¥_pos, H‚ü©
      use Œ¥, Œ¥_pos
      intro x hx
      suffices hh : f x ‚àà B(f x‚ÇÄ, Œµ) from ball_in_U hh
      exact H x hx
    . intro H‚ÇÅ x‚ÇÄ Œµ Œµ_pos
      let U : Set Y := B(f x‚ÇÄ, Œµ)
      have U_open := open_ball_is_open (f x‚ÇÄ) Œµ Œµ_pos
      have recU_open := H‚ÇÅ U U_open
      have x_in_recU: x‚ÇÄ ‚àà f‚Åª¬π' U := by simpa
      obtain ‚ü®Œ¥, Œ¥_pos, H‚ÇÇ‚ü© : ‚àÉ Œ¥ > 0, B(x‚ÇÄ, Œ¥) ‚äÜ f‚Åª¬π' U := recU_open x‚ÇÄ x_in_recU
      use Œ¥, Œ¥_pos
      intro x hx
      exact H‚ÇÇ hx
\end{minted}

On proc√®de une nouvelle fois par double implication :
\begin{itemize}
    \item On veut montrer que l'image r√©ciproque d'un ouvert par une fonction continue est ouverte.
        \begin{itemize}
            \item On prend donc un ouvert, un point dans l'image r√©ciproque de cet ouvert ainsi qu'une boule ouverte dans l'ouvert.
            \item Par l'hypoth√®se de continuit√©, on obtient alors \lean{Œ¥} tel que \lean{‚àÄ (x : X), d x‚ÇÄ x < Œ¥ ‚Üí d (f x‚ÇÄ) (f x) < Œµ}. On utilise ce \lean{Œ¥} comme rayon de la boule dans l'image r√©ciproque
            \item Il suffit alors de prouver que l'image de tout point de la boule dans l'image r√©ciproque est dans la boule de l'ouvert de d√©part, ce qui est vrai par continuit√© de la fonction
        \end{itemize}
    \item R√©ciproquement, on veut montrer la continuit√© de la fonction lorsqu'elle conserve les ouverts par image r√©ciproque.
        \begin{itemize}
            \item On se donne donc un point \lean{x‚ÇÄ} et un \lean{Œµ} (strictement positif). On prend alors comme ouvert la boule centr√©e en \lean{f x‚ÇÄ}, dont l'image r√©ciproque est ouverte par hypoth√®se.
            \item Il existe alors une boule de rayon \lean{Œ¥} dans l'image r√©ciproque, on peut donc prendre ce \lean{Œ¥} et on a bien la continuit√© de la fonction.
        \end{itemize}
\end{itemize}

On montre ensuite, √† l'aide du crit√®re topologique, que la compos√©e de deux applications continues est continue :

\begin{minted}{lean}
theorem comp_continuous (f : X ‚Üí Y) (g : Y ‚Üí Z) : Continuous f ‚Üí Continuous g ‚Üí Continuous (g ‚àò f) :=
  by
    intro f_cont g_cont
    rw [topologic_continuity] at *
    intro V V_open
    let U := g‚Åª¬π' V
    have U_open : is_open U := g_cont V V_open
    exact f_cont U U_open
\end{minted}

On se donne deux fonctions et les hypoth√®ses de continuit√©, on r√©√©crit le but et les hypoth√®ses √† l'aide de l'√©quivalence entre les d√©finitions m√©trique et topologique, on se donne un ouvert et il suffit d'en prendre l'image r√©ciproque par \lean{g} (qui est ouvert par continuit√© de \lean{g}) puis l'image r√©ciproque par \lean{f} de l'image r√©ciproque par \lean{g}, qui est ouverte par continuit√© de \lean{f}.

On finit cette section en √©tudiant le cas des fonctions lipschitziennes :

\begin{minted}{lean}
def Lipschitz (f : X ‚Üí Y) : Prop :=
  ‚àÉ k > 0, ‚àÄ x x' : X, d_[Y] (f x) (f x') ‚â§ k * d_[X] x x'

theorem lipschitz_implies_continuous (f : X ‚Üí Y) : Lipschitz f ‚Üí Continuous f :=
  by
    intro ‚ü®k, k_pos, h‚ü©
    intro x‚ÇÄ Œµ Œµ_pos
    use Œµ / k, div_pos Œµ_pos k_pos
    intro x hdx
    have h‚ÇÅ : d_[Y] (f x‚ÇÄ) (f x) < k * (Œµ / k) := lt_of_le_of_lt (h x‚ÇÄ x) (mul_lt_mul_of_pos_left hdx k_pos)
    rw [mul_div_cancel' Œµ] at h‚ÇÅ
    . exact h‚ÇÅ
    . linarith
\end{minted}

On se donne l'hypoth√®se de lipschitziannit√© de \lean{f}, ainsi qu'un point quelconque \lean{x‚ÇÄ} et un \lean{Œµ}. On veut montrer la continuit√© en \lean{x‚ÇÄ}. On choisit donc \lean{Œ¥ := Œµ / k}, qui est bien strictement positif car quotient de r√©els strictement positifs. On conclut en montrant que l'on a bien \lean{d_[Y] (f x‚ÇÄ) (f x) < Œµ}.

\subsubsection{Ferm√©s}

On finit en d√©finissant les ferm√©s et l'adh√©rence. Commen√ßons par les ferm√©s :

\begin{minted}{lean}
def is_closed (F : Set X) := is_open F·∂ú

lemma union_closed_is_closed : ‚àÄ F G : Set X, is_closed F ‚Üí is_closed G ‚Üí is_closed (F ‚à™ G) :=
  by
    intro F G F_closed G_closed
    rw [is_closed, Set.compl_union F G]
    exact inter_open_is_open F·∂ú G·∂ú F_closed G_closed

lemma inter_closed_is_closed (I : Set (Set X)) : (‚àÄ F ‚àà I, is_closed F) ‚Üí is_closed (‚ãÇ‚ÇÄ I) :=
  by
    intro h
    rw [is_closed, Set.compl_sInter I]
    have h‚ÇÅ : ‚àÄ U ‚àà compl '' I, is_open U :=
      by
        intro U hU
        simp [Set.image] at hU
        obtain ‚ü®F, hF‚ü© := hU
        rw [‚ÜêhF.right]
        exact h F hF.left
    exact union_open_is_open (compl '' I) h‚ÇÅ
\end{minted}

Un ferm√© est donc le compl√©mentaire d'un ouvert. Les deux lemmes reposent sur leurs analogues pour les ouverts. Pour le premier, il suffit de passer au compl√©mentaire puis d'appliquer le lemme sur l'intersection de deux ouverts. Dans le second cas, on passe au compl√©mentaire dans l'intersection quelconque et on montre que tout les ensembles sont ouverts, puis on conclue avec le lemme sur l'union quelconque d'ouverts.

Enfin, on d√©finit l'adh√©rence et quelques lemmes :

\begin{minted}{lean}
def Closure (E : Set X) : Set X := ‚ãÇ‚ÇÄ {F : Set X | is_closed F ‚àß E ‚äÜ F}

@[simp]
lemma closure_is_closed {E : Set X} : is_closed (Closure E) := inter_closed_is_closed {F : Set X | is_closed F ‚àß E ‚äÜ F} fun _ => And.left

lemma sub_closure {E : Set X} : E ‚äÜ Closure E :=
    Set.subset_sInter fun _ => And.right

lemma closure_sub_closed {E F : Set X} : is_closed F ‚Üí E ‚äÜ F ‚Üí Closure E ‚äÜ F :=
  fun hClosed hSub => Set.sInter_subset_of_mem ‚ü®hClosed, hSub‚ü©

lemma closure_monotone {A B : Set X} (h : A ‚äÜ B) : Closure A ‚äÜ Closure B :=
    closure_sub_closed closure_is_closed (Set.Subset.trans h sub_closure)

lemma closure_closed_is_closed {E : Set X} (h : is_closed E) : Closure E = E :=
  Set.Subset.antisymm (closure_sub_closed h (Set.Subset.refl E)) sub_closure

lemma closure_closure_eq_closure {E : Set X} : Closure (Closure E) = Closure E := closure_closed_is_closed closure_is_closed
\end{minted}

\subsection{Compl√©tude}

La compl√©tude n√©cessite un certain nombre de d√©finitions , telles que les suites de Cauchy, la caract√©risation s√©quentielle de la fermeture par exemple.

\subsubsection{D√©finitions}

La premi√®re chose a d√©finir est une suite de Cauchy :

\begin{minted}{lean}
def CauchySeq (u : ‚Ñï ‚Üí X) := ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï , ‚àÄ m ‚â• N,‚àÄ n ‚â• N, d (u m) (u n) < Œµ
\end{minted}

Ainsi qu'un espace complet :

\begin{minted}{lean}
def Complet (Y : Type v) [MetricSpace Y] := ‚àÄ u : ‚Ñï ‚Üí Y, CauchySeq u ‚Üí Converg u
\end{minted}

On rappelle que \lean{d} est la distance d√©finie plus haut.


\subsubsection{Quelques Lemmes}

\textbf{Une suite convergente est de Cauchy}\\

Le lemme suivant est assez simple dans le raisonnement. Il m'a aid√© dans la prise en main et la compr√©hension de Lean.

\begin{minted}{lean}
theorem Converg_Cauchy (u : ‚Ñï ‚Üí X) : Converg u ‚Üí CauchySeq u :=
  by
    intro ‚ü®l, hl‚ü©
    intro Œµ Œµ_pos
    have HŒµ : 0 < Œµ / 2 := by linarith
    obtain ‚ü®N, hN‚ü© := hl Œµ/2
    use N
    intro m hm
    intro n hn
    have hd : d (u n) (u m) ‚â§ d (u n) l + d l (u m) := dist_triangle
    have h‚ÇÅ : d (u n) l < Œµ/2 := @dist_symm X _ _ _ ‚ñ∏ hN n hn
    have h‚ÇÇ : d (u m) l < Œµ/2 := @dist_symm X _ _ _ ‚ñ∏ hN m hm
    have hŒµ := add_lt_add h‚ÇÅ h‚ÇÇ
    have h : d (u n) (u m) < Œµ/2 + Œµ/2 := lt_trans hd hŒµ
    have E : Œµ/2 + Œµ/2 = Œµ := by linarith
    have H : d (u n) (u m) < Œµ
\end{minted}


Il s'agit de la preuve qu'une suite de Cauchy est convergente.
L'instruction \lean{intro ‚ü®l, hl‚ü©} introduit l'hypoth√®se de convergence en utilisant l existence de la limite \lean{l} ainsi que en la notant hl. Nous disposons maintenant de l'√©nonc√© g√©n√©ral : $$\forall \varepsilon \geq 0 \exists N \in \mathbb{N},\forall n \geq N, d (u n) (l) < \varepsilon$$. Nous introduisons donc la quantit√© $\varepsilon$ que nous divisons par 2 dans l hypoth√®se He pour la suite de la preuve.
Gr√¢ce a l hypoth√®se, nous avons un $N$ entier appliqu√© a cet $\varepsilon$/2 par \lean{obtain ‚ü®N, hN‚ü© := hl Œµ/2 h} qui est utilis√© avec \lean{use N}.

On invoque un n et m > N pour continuer de parcourir l'hypoth√®se pour arriver au c≈ìur de la preuve de ce lemme. Nous avons besoin de deux √©nonc√©s

\begin{itemize}
    \item \lean{hd} qui consiste a montrer que \lean{d (u n) (u m) ‚â§ d (u n) l + d l (u m)} par l'in√©galit√© triangulaire
    \item \lean{h1} et \lean{h2} utilisent l'hypoth√®se de convergence appliqu√©es respectivement au \lean{n} et \lean{m} et $\varepsilon/2$
\end{itemize}

Les √©nonc√©s he et h condensent les in√©galit√©s pr√©c√©dentes avec successivement
\begin{itemize}
    \item $a \leq b \land c\leq d \implies a+b \leq c+d$ (\lean{add_lt_add})
    \item $a \leq b \land b \leq c \implies a\leq c$ (\lean{lt_trans}) appliqu√©e √† \lean{hd} et \lean{he}
\end{itemize}

Il ne nous reste plus qu'√† pr√©ciser a Lean que \lean{Œµ/2 + Œµ/2 = Œµ} gr√¢ce a la tactique \lean{linarith} pour finir la preuve.

\vspace{\baselineskip}
\textbf{Une suite de Cauchy est born√©e}\\

Le second lemme est le caract√®re born√©e des suites de Cauchy :

\begin{minted}{lean}
lemma Cauchy_borne (u : ‚Ñï ‚Üí X) : (h : CauchySeq u) ‚Üí Bornee u := by
    unfold CauchySeq
    unfold Bornee
    intro h
    specialize h (1: ‚Ñù)
    have h1 : (1:‚Ñù) >0 := by
      simp
    specialize h h1
    obtain ‚ü®N, hN‚ü© := h
    have fintype.D := { d (u N) (u n) | n : Fin (N-1)}
    -- have M := D.max
    intro n
\end{minted}


La tactique \lean{unfold} d√©ploie les d√©finitions de \lean{CauchySeq} et \lean{Bornee} dans les hypoth√®ses et le but. Nous introduisons l'hypoth√®se \lean{h} qui est le fait que la suite \lean{u} est de Cauchy. Le d√©but de \lean{h} √©tant une g√©n√©ralit√©, nous sp√©cialisons le \lean{Œµ} en 1 pour faciliter la preuve. (En effet, sans sp√©cifier le epsilon choisit, il faudrait utiliser l'axiome du choix). L'√©nonce \lean{h1} montre que 1 pris dans les r√©els est bien strictement positif, crit√®re que doit valider tout choix d'epsilon. Comme pr√©c√©demment, la tactique \lean{obtain ‚ü®N, hN‚ü©} donne le \lean{N} associ√© a 1 (vu comme un epsilon quelconque) et note \lean{hN} la suite de l'√©nonc√© : \lean{hN : ‚àÄ m ‚â• N, ‚àÄ n ‚â• N, d (u m) (u n) < 1}. La suite de la preuve consiste en la recherche d un majorant M r√©el √† l'ensemble des distances possibles entre les termes de la suite et un point \lean{x} de \lean{X}. Ici, nous choisissons le \lean{N}i√®me terme de la suite \lean{u} comme point de r√©f√©rence.

De deux choses l'une :
\begin{itemize}
    \item si $M \geq 1$, M majore alors tous les termes de la suite d (u N) (u n)
    \item si $M \leq  1$ , M <- 1 et 1 est un majorant de la suite d (u N) (u n)
\end{itemize}

On d√©finit $D := \{d\ (u\ N)\ (u\ n)\ \mid\ n \leq N-1\}$, l'ensemble des distances entre \lean{u N} et tous les autres termes \lean{u} d'indices inf√©rieurs a \lean{N}. On note \lean{M} le max de cet ensemble.

Une autre m√©thode, plus algorithmique, serait de faire une induction sur n < N : poser $M := d\ (u\ N)\ (u\ 0)$ puis comparer $M$ aux autres distances. D√®s que $M$ est d√©pass√© par une distance, ce nouveau majorant remplace l'ancienne valeur de $M$.

Supposons le M obtenu, il reste a major√© les termes d indices sup√©rieures a N. Ils le sont d√©s le d√©part par l hypoth√®se que la suite est de Cauchy. Le majorant de la suite sera donc le maximum entre M et 1, comme annonc√©.


\textbf{Une suite de Cauchy ayant une valeur d adh√©rence converge}\\

Enfin, voici un dernier lemme sur la convergence des suites de Cauchy, principalement utilis√©e dans le chapitre sur la compacit√©.

\begin{minted}{lean}
lemma Cauchy_val_adherence_conv (u : ‚Ñï ‚Üí X) (l : X) (f : ‚Ñï ‚Üí ‚Ñï)
    (h1 : strictement_croissante f) (h2 : lim (u ‚àò f) l) (h3 : CauchySeq u): lim u l := by
  intro Œµ hŒµ
  specialize h3 (Œµ/2) (half_pos hŒµ)
  specialize h2 (Œµ/2) (half_pos hŒµ)
  obtain ‚ü®N1, hN1‚ü© := h2
  obtain ‚ü®N2, hN2‚ü© := h3
  use Nat.max N1 N2
  intro n hn
  have h : d l (u n) ‚â§ d l (u (f n)) + d (u (f n)) (u n) := dist_triangle
  have ineq1: Nat.max N1 N2 ‚â• N1 := Nat.le_max_left N1 N2
  have ineq2: Nat.max N1 N2 ‚â• N2 := Nat.le_max_right N1 N2

  specialize hN1 n (le_trans ineq1 hn)
  specialize hN2 n (le_trans ineq2 hn)
  specialize hN2 (f n) (le_trans (le_trans ineq2 hn) (stricte_croissance_geq f h1 n))
  rw [Function.comp_apply] at hN1
  rw [dist_symm] at hN2

  linarith
\end{minted}

La fonction \lean{f} suppos√©e strictement croissante (hypoth√®se \lean{h1}) est la suite extractrice. L'hypoth√®se \lean{h2} correspond a l'hypoth√®se d'existence d'une valeur d'adh√©rence. Comme toute preuve d√©butant par une g√©n√©ralit√©, invoquons un epsilon strictement positif. On injecte ensuite la moiti√© de cette quantit√© dans les hypoth√®se \lean{h2} (la convergence de la suite extraite) et \lean{h3} (la suite \lean{u} est de Cauchy).
On obtient ainsi \lean{N1} et \lean{N2} respectivement des hypoth√®ses \lean{h2} et \lean{h3} pour ce \lean{Œµ/2}. Lean a ensuite a sa disposition le maximum de \lean{N1} et \lean{N2} gr√¢ce √† \lean{use Nat.max N1 N2}.

Apr√®s toutes ces invocations et sp√©cialisations, le but de la preuve est le suivant $$\forall n \geq max (N1,N2), d\ l\ (u\ n) \leq \varepsilon$$

On introduit donc un \lean{n} plus grand que $max(N1,N2)$. Pour ce \lean{n}, on √©nonce \lean{h}, prouv√© par l'in√©galit√© triangulaire.
De plus, on introduit deux in√©galit√©s : $max(N1,N2) \geq N1$ $max(N1,N2) \geq N2$ (respectivement \lean{ineq1} et \lean{ineq2}).

Voici les hypoth√®ses √† retenir :
\begin{itemize}
    \item \lean{hN1 : ‚àÄ n ‚â• N1, d l ((u ‚àò f) n) < Œµ / 2}
    \item \lean{hN2 : ‚àÄ m ‚â• N2, ‚àÄ n ‚â• N2, d (u m) (u n) < Œµ / 2}
\end{itemize}

Et le but de preuve est : \lean{d l (u n) < Œµ}.

Tout d'abord, nous prouvons que le \lean{n} invoqu√© au d√©but de la preuve est effectivement sup√©rieur √† \lean{N1} et \lean{N2} pour pouvoir utiliser les hypoth√®ses, gr√¢ce au th√©or√®me \lean{le_trans} respectivement appliqu√© aux couples d'hypoth√®ses \lean{ineq1 hn} et \lean{ineq2 hn}. On rappelle que \lean{hN2} d√©pend de deux g√©n√©ralit√©s en \lean{m > N2} et \lean{n > N2}. On souhaite sp√©cialiser \lean{m} en \lean{f(n)} par \lean{specialize hN2 (f n)}; la suite de la ligne montre que \lean{m > N}.
On r√©√©crit la composition de l'hypoth√®se \lean{hN1} pour faire correspondre les expressions : \lean{(u ‚àò f) n)} et \lean{u(f n)}. Enfin, la tactique \lean{linarith} vient synth√©tiser les hypoth√®ses \lean{hN1} et \lean{hN2} pour conclure au but.


\subsubsection{Th√©oreme du point fixe de Banach Picard}

Il reste a montrer le th√©or√®me central de ce chapitre : le th√©or√®me du point fixe contractant de Banach picard.

\begin{minted}{lean}
theorem Point_Fixe_Contractant (f : X -> X) : (Complet X ‚àß contractant f ‚àß ‚àÄ u :‚Ñï -> X, ‚àÄ n , f (u n) = u (Nat.succ n)) -> (‚àÉ!x:X,f x =x ‚àß lim u x) :=
  by
    unfold contractant
    have C := d (u 0) (u 1)
    intro H
    obtain ‚ü®k, hk‚ü© := H.2

    have h : ‚àÄ n : ‚Ñï , d (u (Nat.succ n)) (u n) < k^n*C := sorry
    -- cf exercice 50 du poly de topo

    have l : ‚àÄ Œµ>0 ,‚àÉ N , ‚àÄ n > N ,d (u (Nat.succ n)) (u n) < Œµ := sorry
    -- preuve que k^n*C tend vers zero puis thm des gendarmes

    have hp : ‚àÄ n p : ‚Ñï , d (u n) (u (n + p)) < ((k^n)/(1-k))*C := sorry
    -- IT generalis√©e et recurrence sur p

    have lp : ‚àÄ Œµ>0 ,‚àÉ N ,‚àÄ p ‚â• N,‚àÄ n ‚â• N, d (u p) (u n) < Œµ := sorry
    -- encore une preuve de convergence vers 0

    have Cauchy : CauchySeq u := by exact lp
    have Conv : Converge u := by exact H.1 u Cauchy
\end{minted}



\subsection{Compacit√©}

La notion de compacit√© a √©merg√© au 19 √®me si√®cle dans le contexte du d√©veloppement de l'analyse math√©matique afin de mieux formaliser les notions de convergences et de continuit√©. Nous choisissons de la d√©finir d'abord de mani√®re s√©quentielle plus simple et adapt√©e aux espaces m√©triques. Puis nous montrerons les grandes lignes de son lien avec la continuit√©, la fermeture et la compl√©tude. Enfin nous nous orienterons vers une d√©finition ensembliste qui s'approche de celle qui √©tend la compacit√© aux espaces topologiques quelconques. Cependant nous n'aborderons pas la topologie g√©n√©rale qui n'est pas au programme de L3.


\subsubsection{D√©finitions}

\begin{minted}{lean}
variable {X Y : Type u} [MetricSpace X] [MetricSpace Y]
\end{minted}

On introduit deux espaces m√©triques $(X,d_{X})$ et $(Y,d_{Y})$ gr√¢ce √† la commande \lean{variable}. X et Y sont munis des distances respectives \lean{d_{X}} et \lean{d_{Y}} d√©fini par \lean{MetricSpace X} et \lean{MetricSpace Y}, ainsi le type X d√©signera $(X,d_{X})$ et le type Y d√©signera $(Y,d_{Y})$.\\

D'apr√®s le cours un espace m√©trique \lean{X} est compact si et seulement si de toute suite d'√©l√©ments de \lean{X} on peut extraire une sous-suite convergente. Nous d√©finirons un compact par cette propri√©t√©. Mais avant, voici quelque lemmes et d√©finitions pr√©liminaires.

\begin{minted}{lean}
def strictement_croissante (f : ‚Ñï ‚Üí ‚Ñï) : Prop := ‚àÄ n m : ‚Ñï, n > m -> f n > f m
def croissante (f : ‚Ñï ‚Üí ‚Ñï) : Prop := ‚àÄ n m : ‚Ñï, n >= m ‚Üí f n >= f m
\end{minted}

\lean{croissante} et \lean{stricte_croissante} sont les d√©finitions respectives de la croissance et stricte croissance d'une fonction de $\mathbb{N}$ dans $\mathbb{N}$. Ensuite le lemme \lean{stricte_croissante_to_croissante} prouve qu'une fonction strictement croissante est croissante:

\begin{minted}{lean}
lemma stricte_croissante_to_croissante (f : ‚Ñï ‚Üí ‚Ñï) : strictement_croissante f ‚Üí croissante f :=
  by
    intro hf n m hnm
    apply Or.elim (Nat.eq_or_lt_of_le hnm)
    . exact Nat.le_of_eq ‚àò congrArg f
    . exact Nat.le_of_lt ‚àò hf n m
\end{minted}


\begin{itemize}[align=left,itemsep=20pt]
    \item[\textbf{intro:}] Cette preuve commence par l'introduction de \lean{hf} l'hypoth√®se de la strict croissance de \lean{f} , \lean{n} et \lean{m} deux entiers naturels et
    \lean{hnm} l'hypoth√®se \lean{n ‚â• m}. Le but est de type \lean{f n ‚â• f m}.
    \item[\textbf{apply:}] Le lemme de mathlib \lean{Nat.eq_or_lt_of_le} appliqu√© √† \lean{hnm} montre que \lean{n ‚â• m} implique "\lean{n} = \lean{m} ou \lean{n ‚â• m}". Ainsi par composition avec la tactique \lean{apply Or.elim}, on obtient une disjonction de cas.
    \item[\textbf{exact:}] Nous obtenons alors deux buts. Le premier, \lean{m = n -> f n ‚â• f m} se montre par la fonction \lean{congrArg}, elle prend en argument \lean{f} et renvoie que l'√©galit√© des ant√©c√©dents implique l'√©galit√© des images. Puis le lemme de mathlib \lean{Nat.le_of_eq} √©largi l'√©galit√© des images √† l'in√©galit√© souhait√©e. Le second but \lean{ n > m -> f n >= f m} se montre par \lean{hf} avant d'√©largir l'in√©galit√© strict par \lean{Nat.le_of_lt}. Ainsi dans les deux cas, la tactique \lean{exact} prouve que la propri√©t√© obtenu est exactement celle attendue.
\end{itemize}


\vspace{\baselineskip}

D'autres lemmes que nous avons cod√© mais que nous ne commenterons pas seront utilis√©s dans cette partie, ils sont accessibles dans notre r√©pertoire git \cite{git_repo}.

Nous pouvons √† pr√©sent prouver que si une suite converge alors toute suite extraite converge vers la m√™me limite:

\begin{minted}{lean}
lemma limite_suite_extraite (K : Set X) (x : ‚Ñï ‚Üí K) (l : X) (f : ‚Ñï ‚Üí ‚Ñï) : lim x l ‚àß strictement_croissante f -> lim (x ‚àò f) l :=
  by
    rintro ‚ü®hx, hf‚ü© Œµ hŒµ
    obtain ‚ü®N, hN ‚ü© := hx Œµ hŒµ
    use N
    intro n hn
    have t : f n >= f N := stricte_croissante_to_croissante f hf n N hn
    apply hN
    have sup_N: f N >= N := stricte_croissance_geq f hf N
    linarith [t, stricte_croissance_geq f]
\end{minted}

\begin{itemize}[align=left,itemsep=20pt]
    \item [\textbf{rintro:}] Dans ce contexte la tactique \lean{rintro} permet d'introduire s√©par√©ment \lean{hx} (de type lim x l) et \lean{hf} (de type \lean{strictement_croissante f}), le but √©tant une implication, les hypoth√®ses de d√©part sont introduites en premier. \lean{rintro} introduit ensuite \lean{Œµ} et \lean{hŒµ} (de type \lean{Œµ>0} d'apr√®s l'expression du but qui commence par le quantificateur $\forall$ (voir d√©finition de \lean{lim}).
    \item [\textbf{obtain:}] Ainsi on obtient \lean{N} un entier naturel et \lean{hN} de type \lean{‚àÄ n ‚â• N, d l ‚Üë(x n) < Œµ} par \lean{hx} appliqu√© √† \lean{Œµ} et \lean{hŒµ}.
    \item [\textbf{use:}] Le but √©tant alors \lean{‚àÉ N, ‚àÄ n ‚â• N, d l ‚Üë((x ‚àò f) n) < Œµ}, la tactique \lean{ use N} fait que le but soit de montrer que \lean{N} convient.
    \item [\textbf{intro:}] On introduit alors \lean{n} et \lean{hn} puisque le but commence encore une fois par le quantificateur $\forall$.
    \item [\textbf{apply:}] Il reste √† montrer \lean{d l ‚Üë((x ‚àò f) n) < Œµ}. Nous appliquons \lean{ hN} au but, ainsi il reste √† montrer que \lean{f n ‚â• N}.
    \item [\textbf{have:}] \lean{stricte_croissante_to_croissante} d√©montr√©e pr√©c√©demment appliqu√©e √† \lean{f} et \lean{hf} nous donne la croissance de \lean{f}. Puis la d√©finition de la croissance de \lean{f} appliqu√©e √† \lean{n},\lean{N} et \lean{hn} nous donne la propri√©t√© que nous avons nomm√© \lean{t} par la tactique have.
    \item [\textbf{have:}] De m√™me, \lean{ stricte_croissance_geq} appliqu√© √† \lean{f}, \lean{hf} et \lean{N} nous donne la propri√©t√© que nous avons nomm√©e \lean{sup_N}.
    \item [\textbf{linarith:}] Enfin, par combinaison lin√©aire de ces deux derni√®res hypoth√®ses,la tactique \lean{linarith} r√©sout automatiquement le but.
\end{itemize}

\vspace{\baselineskip}
\vspace{\baselineskip}

\begin{minted}{lean}
def lim' (x : ‚Ñï ‚Üí Œ±) (l : Œ±) [MetricSpace Œ±]:= ‚àÄ Œµ > 0, ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, d l (x n) < Œµ
\end{minted}

Cette d√©finition de la limite prend en argument une suite \lean{x} de $\mathbb{N}$ dans $\alpha$, un type quelconque de l'univers \lean{u} √† partir duquel on construit un espace m√©trique gr√¢ce √† la syntaxe \lean{[MetricSpace Œ±]}. \lean{lim'} prend en second argument un √©l√©ment de $\alpha$, puis elle d√©fini la convergence de la suite \lean{x} vers cet √©l√©ment.\\

Nous pouvons √† pr√©sent d√©finir un espace m√©trique compact:

\begin{minted}{lean}
def Compact (K : Type u) [MetricSpace K] : Prop := ‚àÄ x : ‚Ñï ‚Üí K , ‚àÉ f : ‚Ñï ‚Üí ‚Ñï, ‚àÉ l, (strictement_croissante f ‚àß lim' (x ‚àò f) l)
\end{minted}

Cette d√©finition prend encore une fois un type quelconque de \lean{u} en argument et elle en fait un espace m√©trique. Pour toute suite \lean{x}, l'existence d'une suite extraite est par d√©finition √©quivalente √† l'existence d'une fonction strictement croissante de $\mathbb{N}$ dans $\mathbb{N}$ que l'on compose par \lean{x}. Ainsi, la compacit√© se d√©fini par l'existence d'une telle fonction ainsi que celle d'un √©l√©ment \lean{l} vers lequel la fonction compos√©e converge.

\begin{minted}{lean}
def is_compact (K : Set X) : Prop := ‚àÄ x : ‚Ñï ‚Üí K, ‚àÉ f : ‚Ñï ‚Üí ‚Ñï, ‚àÉ l ‚àà K, strictement_croissante f ‚àß lim (x ‚àò f) l
\end{minted}

Une partie d'un espace m√©trique est compact si le sous-espace m√©trique correspondant est compact. √âtant donn√© que la distance se conserve pour tout sous-espace m√©trique, il n'est pas n√©cessaire de d√©finir explicitement un nouvel espace m√©trique. Une partie \lean{K} de \lean{X} est un type de \lean{Set X} et tout √©l√©ment de \lean{K} est effectivement un type de \lean{X}. Ainsi \lean{K} conserve les propri√©t√©s de \lean{X}. Il suffit donc d'ajuster la d√©finition pr√©c√©dente en rempla√ßant \lean{‚àÄ x : ‚Ñï ‚Üí X} par \lean{‚àÄ x : ‚Ñï ‚Üí K}, ainsi que \lean{lim'} par \lean{lim}. En effet, \lean{lim} prend en argument une suite √† valeur dans un type de \lean{Set X} et \lean{lim'} ne conviens qu'√† une suite √† valeurs dans \lean{X}.

\subsubsection{R√©sultats li√©s √† la fermeture, la continuit√© et la compl√©tude }

Nous commen√ßons par quelques r√©sultats sur la fermeture. Tout d'abord, montrons qu'une partie compact de \lean{X} est ferm√© dans \lean{X}

\begin{minted}{lean}
lemma compact_is_closed : ‚àÄ K : Set X, is_compact K ‚Üí is_closed K :=
  by
    intro K h
    contrapose! h
    have diff : Closure K ‚â† K := by
      intro absurde
      have j : is_closed (Closure K) := by exact closure_is_closed
      rw [absurde] at j
      apply h at j
      exact j

    have c : K ‚äÇ Closure K :=
      Set.ssubset_iff_subset_ne.mpr ‚ü®sub_closure, diff.symm‚ü©
    have l_in_closure_not_in_K : ‚àÉ l : X, l ‚àà Closure K ‚àß l ‚àâ K :=
      Set.exists_of_ssubset c

    rcases l_in_closure_not_in_K with ‚ü®l, l_in_closure, l_not_in_K‚ü©
    obtain ‚ü®x, hx‚ü© := (sequential_closure K l).mp l_in_closure

    intro compacite
    choose f l' hl' hf lim_l' using compacite x
    have lim_l : lim (x ‚àò f) l := limite_suite_extraite K x l f ‚ü®hx, hf‚ü©
    have egalite: l = l':= by apply unicite_limite K (x ‚àò f) l l' lim_l lim_l'
    rw [egalite] at l_not_in_K
    apply l_not_in_K at hl'
    exact hl'
\end{minted}

Afin d'expliquer cette preuve de mani√®re claire et d√©taill√©e, nous la diviserons en plusieurs parties.

\begin{itemize}[itemsep=30pt]
    \item \textbf{Raisonnement par contrapos√©e}\\
        Comme le but est une implication de la forme $ \forall x, P(x) \implies Q(x)$, la tactique \lean{intro} introduit d'abord $x$ puis $P(x)$. Ici on nomme \lean{K} une partie compact, et \lean{h} l'hypoth√®se de sa compacit√©. Le but devient alors \lean{is_closed K}.\\
        La tactique \lean{contrapose!} permet un raisonnement par contrapos√©e. le but devient la n√©gation de \lean{h} et h devient la n√©gation du but pr√©c√©dent.
    \item \textbf{Construction d'une suite de \lean{K} convergeant dans \lean{X} exlu de \lean{K} }\\
        Nous nommons \lean{diff} la propri√©t√© que l'adh√©rence de \lean{K} est diff√©rente de \lean{K}. La tactique \lean{have} nous permet √† la fois d'emboiter une "sous" preuve et de nommer la propri√©t√© prouv√©e. Par souci de clart√© nous d√©taillerons la preuve de \lean{diff} dans un second temps. Nous ferons de m√™me pour \lean{c : K ‚äÇ Closure K } puis \lean{l_in_closure_not_in_K}, preuve de l'existence de \lean{l} appartenant √† l'adh√©rence de \lean{K} exclue de \lean{K}.\\
        \lean{recases} nous permet d'introduire s√©par√©ment un tel \lean{l} puis les propri√©t√©s v√©rifi√©es par \lean{l}.\\
        Ensuite par la tactique \lean{obtain}, nous appliquons le lemme \lean{sequential_closure} pour \lean{K} et \lean{l} dans le sens direct (\lean{.mp}).\\
        Ainsi le crit√®re de fermeture s√©quentielle nous donne l'existence d'une suite de \lean{K} convergente vers \lean{l}. \lean{obtain} nous permet d'introduire une telle suite ainsi que la propri√©t√© qu'elle v√©rifie puis de les nommer respectivement \lean{x} et \lean{hx}.
    \item \textbf{ Preuve que \lean{x} n'admet pas de valeur d'adh√©rence}\\
        Enfin, Le goal √©tant la n√©gation d'une proposition, \lean{intro} introduit cette proposition et change le but en \lean{False}. Ainsi par l'absurde nous montrerons que \lean{x}, n'admet pas de valeur d'adh√©rence dans \lean{K}, donc que \lean{K} n'est pas compact. \\
        \lean{K} est suppos√© compact donc \lean{choose } applique la d√©finition de la compacit√© √† x, et prend alors une suite extraite de \lean{x} qui converge dans \lean{K }vers \lean{l'}, on nomme \lean{hl'} l'hypoth√®se que \lean{l'} est dans \lean{K}.\\
        Nous prouvons ensuite que cette suite extraite tend vers \lean{l} par le lemme \lean{limite_suite_extraite} d√©montr√©e plus haut. Puis nous prouvons que \lean{l=l'} par unicit√© de la limite.\\
        La tactique \lean{rw} prend en argument une √©galit√© et en pr√©cisant \lean{at l_not_in_K } elle remplace dans \lean{l_not_in_K} le membre de gauche par le membre de droite. Ainsi \lean{l_not_in_K} devient \lean{l'} n'appartient pas √† \lean{K}. Ceci est en contradiction avec \lean{hl'}.\\
        Par cons√©quent \lean{apply l_not_in_K at hl'} change \lean{hl'} en \lean{False}.\\
        Enfin quand une hypoth√®se est √©gale au but, il suffit d'appliquer la tactique \lean{exact}, ce qui termine la preuve.
\end{itemize}

\vspace{\baselineskip}
Revenons sur l'hypoth√®se \lean{diff}, le but est la n√©gation d'une √©galit√©, donc la tactique \lean{intro} introduit l'hypoth√®se de l'√©galit√© et change le but en \lean{False}. Ceci nous permet de r√©sonner par l'absurde. Ensuite, le lemme de la fermeture de l'adh√©rence appliqu√© √† \lean{K} et nomm√© \lean{j}.\lean{rw} remplace alors \lean{Closure K} par \lean{K} dans \lean{j}. D'o√π une contradiction avec \lean{h}. Par cons√©quent \lean{apply h at j} change \lean{j} en \lean{False}. Encore une fois, \lean{j} est exactement le but, donc \lean{exact j} termine la preuve. L'hypoth√®se suivante \lean{c} est d√©duite de \lean{diff} par \lean{Set.ssubset_iff_subset_ne}, un lemme de mathlib utilis√© dans le sens indirect (\lean{.mpr}). Il prend en argument \lean{sub_closure}, l'inclusion de tout ensemble dans son adh√©rence, en particulier pour \lean{K} (argument implicite), puis \lean{diff.symm} o√π \lean{.symm} permet d'inverser les membres de gauche et de droite. Enfin l'hypoth√®se \lean{l_in_closure_not_in_K} est d√©duite de l'inclusion strict de \lean{c} par le lemme de Mathlib \lean{Set.exists_of_ssubse}.\\

Les preuves suivantes seront moins d√©taill√©es afin d'√©viter de trop se r√©p√©ter, tous les th√©or√®mes commen√ßant par \lean{Set.} et \lean{Function.} proviennent de Mathlib. Poursuivons avec la proposition que toute partie ferm√©e d'une partie compacte est compacte.\\


\begin{minted}{lean}
lemma subcompact_closed_is_compact (K H: Set X) (k_compact : is_compact K) (h_sub: H ‚äÜ K) (h_closed : is_closed H) : is_compact H := by
  intro x
  have x_in_k : ‚àÄ (n : ‚Ñï), (x n : X) ‚àà K := by
    intro n
    apply Set.mem_of_subset_of_mem h_sub
    apply (x n).2

  let y : ‚Ñï ‚Üí K := Œª n ‚Ü¶ ‚ü®x n, x_in_k n‚ü©
  obtain ‚ü®f, l, _, croiss_f, lim_in_K‚ü© := k_compact y

  have l_in_h : l ‚àà Closure H := by apply (sequential_closure H l).mpr ‚ü®x ‚àò f, lim_in_K‚ü©
  rw [closure_closed_is_closed] at l_in_h
  use f, l, l_in_h, croiss_f
  have eg : ‚àÄ n , x n = (y n : X) := by
    intro n
    rfl
  have lim_xf : lim (x ‚àò f) l := by
    intro Œµ hŒµ
    obtain ‚ü®N, hN‚ü© := lim_in_K Œµ hŒµ
    use N
    intro n hn
    specialize hN n hn
    have eg : x (f n) = (y (f n) : X) := eg (f n)
    rw [Function.comp_apply]
    rw [Function.comp_apply] at hN
    rw [<- eg] at hN
    exact hN

  exact lim_xf
  exact h_closed
\end{minted}

\begin{itemize}
    \item Nous montrons que \lean{H} est compact. Nous prenons donc une suite \lean{x} √† valeurs dans \lean{H} et nous montrons l'existence d'une suite extraite convergente.

    \item Pour tout \lean{n}, montrer que \lean{x n} est dans \lean{K} revient √† montrer que \lean{x n} est dans \lean{H}, ceci d√©coule de l'inclusion de \lean{H} dans \lean{K}, nous changeons le but de cette mani√®re par \lean{Set.mem_of_subset_of_mem}. Comme \lean{x n} contient la proposition d'appartenance √† \lean{H} en deuxi√®me position, nous appliquons \lean{(x n).2}\\

    \item Par la compacit√© de\lean{K} nous posons une suite de \lean{K} co√Øncidant avec \lean{x} et nous lui associons la suite extraite convergente \lean{y} compos√© par \lean{f}.\\

    \itemLa limite \lean{l} de cette sous-suite est dans \lean{K} mais par \lean{sequential_closure} dans le sens indirect nous montrons que \lean{l} est dans l'adh√©rence de \lean{H}, en effet la compos√© \lean{x} par \lean{f} est une suite de \lean{H} et elle converge vers \lean{l} la limite de la sous-suite de \lean{y} puisque elle co√Øncide avec cette derni√®re.\\

    \item Rappelons que \lean{closure_closed_is_closed} nous donne l'√©galit√© de tous ferm√© avec son adh√©rence. Donc \lean{l} est dans \lean{H}.\\

    \item Finalement \lean{f} et \lean{l} sont de bons candidats pour obtenir une sous-suite de \lean{x} convergente dans \lean{H}.\\

    \item Il reste √† montrer que cette sous-suite converge bien vers \lean{l}. On utilise alors la d√©finition de \lean{y} pour obtenir l'√©galit√© \lean{eg}. Puis nous obtenons la
    convergence par une preuve en $\epsilon$ et en appliquant \lean{eg}. \lean{Function.comp_apply} justifie que pour toute fonction $u$, $v$ et pour tout $x$, $(u \circ v) (x) = u(v(x))$
\end{itemize}

\begin{minted}{lean}
lemma closed_incompact_iscompact (hX : Compact X) (K : Set X) (hK : is_closed K) : is_compact K := by
  intro x
  let x' : ‚Ñï ‚Üí X := Œª n ‚Ü¶ x n
  obtain ‚ü®f, l, hf,limite‚ü© := hX x'
  use f
  have eg : ‚àÄ n , x n = x' n:= by
    intro n
    rfl
  have limite2 : lim (x ‚àò f) l := by
    intro Œµ hŒµ
    obtain ‚ü®N , hN‚ü© := limite Œµ hŒµ
    use N
    intro n hn
    specialize hN n hn
    rw [Function.comp_apply]
    rw [Function.comp_apply] at hN
    rw [eg]
    exact hN
  have hl : l ‚àà Closure K := (sequential_closure K l).mpr ‚ü®x ‚àò f, limite2‚ü©
  rw [closure_closed_is_closed hK] at hl
  use l
\end{minted}

\vspace{\baselineskip}

L'image d'un compact par une fonction continue est compact. En voici la preuve formalis√©e en Lean.

\begin{minted} {lean}
lemma image_continuous_compact (f : X ‚Üí Y) (f_continuous: Continuous f) (h_compact : Compact X) : is_compact (Set.image f Set.univ) := by

  intro y
  have hn : ‚àÄ n, ‚àÉ xn ‚àà Set.univ, f xn = y n := by
    intro n
    exact ((Set.mem_image f Set.univ (y n)).mp (y n).2)

  choose x hx using hn
  obtain ‚ü® j, l, croiss_j,lim_in_univ‚ü© := h_compact x
  use j, (f l)

  have hf : f l ‚àà f '' Set.univ := by
    apply (Set.mem_image f Set.univ (f l)).mpr
    use l
    apply And.intro
    exact Set.mem_univ l
    rfl

  apply And.intro
  exact hf
  apply And.intro
  exact croiss_j

  have limite : lim' (f ‚àò x ‚àò j) (f l) := by

    apply (sequential_continous f l).mp (f_continuous l) (x ‚àò j)
    intro Œµ hŒµ
    obtain ‚ü® N, hN ‚ü© := lim_in_univ Œµ hŒµ
    use N

  intro Œµ hŒµ
  obtain ‚ü® N, hN ‚ü© := limite Œµ hŒµ
  use N
  intro n hn
  rw [Function.comp_apply]
  rw [‚Üê(hx (j n)).2]
  specialize hN n hn
  rw [ Function.comp_apply] at hN
  exact hN

\end{minted}

\begin{itemize}
    \item Dans cette preuve \lean{Set.univ} d√©signe l'ensemble des √©l√©ments de \lean{X} et est un type de \lean{Set X}. \lean{Set.image} d√©signe l'image par \lean{f} d'un type de \lean{Set X}. Donc \lean{Set.image} ne peux pas prendre \lean{X} en argument. On prendra donc l'image de \lean{Set.univ}.\\\\

    \item Comme pr√©c√©demment, nous montrons qu'un ensemble est compact en introduisant une suite, il faut alors construire une sous suite qui converge dans cette ensemble. Ici l'ensemble est \lean{Set.image f Set.univ}, ainsi par d√©finition de l'image direct, nous construisons d'abord la suite \lean{x}.

    \itemLa tactique \lean{obtain} introduit une sous suite de \lean{x} convergente, dont l'existence est d√©duite de \lean{h_compact x}.

    \item La tactique \lean{use} propose \lean{j} pour extraire une sous suite de \lean{y} par composition et \lean{f l} pour la limite de cette sous suite. Le but se r√©duit √† v√©rifier que \lean{j} et \lean{f l} sont de bons candidats.

    \item On montre que \lean{f l} est dans \lean{(Set.image f Set.univ}. Cette propri√©t√© est vrai pour tout √©l√©ment de \lean{X}. 

    \item Avant d'appliquer cette propri√©t√©, \lean{apply And.intro} permet de s√©parer les arguments du but \lean{ ‚ä¢ f l ‚àà f '' Set.univ ‚àß strictement_croissante j ‚àß lim (y ‚àò j) (f l)}. On fait de m√™me pour appliquer la stricte croissance de \lean{j}. 

    \item Enfin, la convergence de la sous-suite de \lean{y} est obtenu par continuit√© de \lean{f} en √©crivant \lean{y} comme la compos√©e de \lean{f} par \lean{x}. Cependant, \lean{limite} est prouv√© pour \lean{lim'} car la sous-suite √©crite sous cette forme est √† valeur dans \lean{Y}. Or nous voulons qu'elle converge dans \lean{Set.image f Set.univ} de type \lean{Set Y}.

    \item Ainsi, on montre que \lean{lim} co√Øncide trivialement avec \lean{lim'} par une preuve en epsilon.

\vspace{\baselineskip}

Terminons avec un dernier r√©sultat sur la compl√©tude: tout espace m√©trique compact est complet.

\begin{minted} [breaklines] {lean}
lemma compact_is_complet (K : Type v) [MetricSpace K] : Compact K -> Complet K := by
  intro h x hx
  obtain ‚ü®f, l, hf,lim_l‚ü© := h x
  use l
  apply Cauchy_val_adherence_conv x l f hf lim_l hx
\end{minted}

La preuve est simple. Il suffit d'introduire une suite \lean{x} de Cauchy. Comme \lean{K} est compact (\lean{h}), \lean{x} admet une sous-suite qui converge. On introduit cette sous-suite ainsi que sa limite nomm√©e \lean{l} par la tactique \lean{obtain}. On propose \lean{l} comme candidat de la limite de \lean{x}. Enfin, ceci est v√©rifi√© par le lemme \lean{Cauchy_val_adherence_conv} d√©montr√© dans la section Compl√©tude.

\vspace{\baselineskip}

\subsection{Compacit√© et recouvrements}

Pour tout compact et pour tout rayon \lean{Œ±} il existe un recouvrement fini par des des boules de rayon \lean{Œ±}. Cette propri√©t√© est appel√© pr√©compacit√©. Pour le d√©montrer l'id√©e est de raisonner par contrapos√©e. En supposant l'existence d'un recouvrement fini par des boules de rayon \lean{alpha} , on peut construire une suite dont tout les termes sont s√©par√©s d'une distance sup√©rieur ou √©gale √† \lean{alpha}. Une telle suite ne peut admettre de valeurs d'adh√©rence. La partie la plus complexe de la formalisation de ce lemme en Lean a √©t√© de construire cette suite par r√©currence. Commen√ßons donc par un exemple plus simple d'un tel proc√©d√©, "le petit lemme" \lean{h_suite}:

\begin{minted}{lean}
lemma h_suite (X: Type) (H : (‚àÄ A : Finset X, ‚àÉ x : X, x ‚àâ A)) : (‚àÉ u : ‚Ñï ‚Üí X, ‚àÄ k l, k < l ‚Üí (u k ‚â† u l)) := by
  classical
  choose new h_new using H
  let f := Œª (s : Finset X) ‚Ü¶ insert (new s) s
  let f_set := Œª n ‚Ü¶ Nat.iterate f n ‚àÖ
  have h_rec : ‚àÄ n : ‚Ñï , f_set (n + 1) = f (f_set n) := by
    simp only [f_set]
    intro n
    apply Function.iterate_succ_apply' f

  use new ‚àò f_set
  intro k l h_kl

  have h_in: new (f_set k) ‚àà f_set l := by
    induction l with
    | zero => cases h_kl
    | succ n ih =>
      rw [h_rec]
      simp only [f]
      have h := lt_or_eq_of_le (Nat.lt_succ_iff.mp h_kl)
      rw [Finset.insert_eq]
      cases h with
      | inl h1 =>
        apply ih at h1
        exact Finset.mem_union_right {new (f_set n)} h1

      | inr h2 =>
        rw [h2]
        exact Finset.mem_union_left (f_set n) (Finset.mem_singleton_self (new (f_set n)))
  rw [Function.comp_apply]
  rw [Function.comp_apply]
  intro j
  rw [j] at h_in
  apply h_new ( f_set l) at h_in
  exact h_in
\end{minted}


\begin{itemize}

    \item \textbf{Mise en place des hypoth√®ses}

    La tactique \lean{choose} cr√©e √† partir de \lean{H}, une fonction qui √† tout ensemble fini associe un nouvel √©l√©ment. Nous nommons \lean{new} cette fonction et \lean{h_new} la propri√©t√© qu'elle v√©rifie.

    Ensuite, nous construisons \lean{f} qui a tous ensemble fini \lean{s} associe la r√©union de \lean{s} et de \lean{{new(s)}}. Cette fonction est bien d√©fini car nous avons commenc√© la preuve par \lean{classical}, ceci nous a permis d'utiliser l'axiome du choix dans la construction de \lean{new}.

    Enfin nous d√©finissons la suite \lean{f_set} par it√©ration de \lean{f}. Elle est initialis√© √† \lean{0} par \lean{(f_set 0) = (f \empty)} puis pour tout \lean{n}, \lean{(f_set n+1) = f (f n) }. On obtient donc une suite d'ensembles croissante pour l'inclusion, ou chaque ensemble contient un nouveau terme.

    Nous nommons enfin \lean{h_rec} la relation de r√©currence v√©rifi√©e par cette suite.

    \item \textbf{R√©solution du goal }
    
    Rappelons que notre but est \lean{‚àÉ u, ‚àÄ (k l : ‚Ñï), k < l ‚Üí u k ‚â† u l}. Nous devons alors montrer que la fonction compos√©e \lean{new ‚àò f_set} convient. Nous fixons \lean{k},\lean{kl} tels que \lean{ k<l} et par r√©currence sur \lean{l} nous montrons \lean{h_in: new (f_set k) ‚àà f_set l}. Ensuite, \lean{intro j} suppose l'√©galit√© \lean{new(f_set k)=new (f_set l)} et le but est alors de montrer que c'est faux. La tactique \lean{rw} remplace \lean{new (f_set k)} par \lean{new (f_set l)} dans \lean{h_in}. Nous obtenons alors une contradiction avec \lean{ h_new ( f_set l) }.
\end{itemize}

A pr√©sent voici le lemme qui nous int√©resse :

\begin{minted}{lean}
lemma recouvrement_fini (hX : Compact X) (Œ± : ‚Ñù) (hŒ± : Œ± > 0) : ‚àÉ n, ‚àÉ x : Fin n ‚Üí X, Set.univ ‚äÜ (‚ãÉ xi ‚àà List.ofFn x, B(xi, Œ±)) := by
  contrapose hX
  push_neg at hX
  have h : ‚àÄn, ‚àÄ xn : Fin n ‚Üí X, ‚àÉ un ‚àà Set.univ, un ‚àâ ‚ãÉ xn_i ‚àà List.ofFn xn, B(xn_i,Œ±) := by
    intro n xn
    apply Set.not_subset_iff_exists_mem_not_mem.mp (hX n xn)
  unfold Compact
  push_neg
  have H : ‚àÄ A : Finset X, ‚àÉ a ‚àà Set.univ, a ‚àâ ‚ãÉ xn_i ‚àà A, B(xn_i,Œ±) := by
    intro A
    let s := Finset.toList A
    specialize h s.length
    let x : Fin s.length ‚Üí X := Œª n ‚Ü¶ s.get n
    specialize h x
    obtain ‚ü®a, ha, hna‚ü© := h
    use a
    apply And.intro
    exact ha
    push_neg
    have eg1 : s = List.ofFn x := by
      apply List.ext_get
      rw [List.length_ofFn]
      intro n h1 h2
      simp [x]
    rw [<- eg1] at hna
    simp [s] at hna
    simp
    exact hna

  have h': ‚àÉ u : ‚Ñï ‚Üí X, ‚àÄ k l, k < l ‚Üí (u k ‚â† u l) ‚àß d (u k) (u l) >= Œ± := by
    classical
    choose new h_new using H
    let f := Œª (s : Finset X) ‚Ü¶ insert (new s) s
    let f_set := Œª n ‚Ü¶ Nat.iterate f n ‚àÖ
    use new ‚àò f_set
    intro k l h_kl
    have h_rec : ‚àÄ n : ‚Ñï, f_set (n + 1) = f (f_set n) := by
      simp only [f_set]
      intro n
      apply Function.iterate_succ_apply' f
    have h_in : new (f_set k) ‚àà f_set l := by
      induction l with
      | zero => cases h_kl
      | succ n ih =>
        rw [h_rec]
        simp only [f]
        have h := lt_or_eq_of_le (Nat.lt_succ_iff.mp h_kl)
        rw [Finset.insert_eq]
        cases h with
      | inl h1 =>
        apply ih at h1
        exact Finset.mem_union_right {new (f_set n)} h1
      | inr h2 =>
        rw [h2]
        exact Finset.mem_union_left (f_set n) (Finset.mem_singleton_self (new (f_set n)))
    simp
    push_neg
    apply And.intro
    intro j
    rw [j] at h_in
    have g : (f_set l : Set X) ‚äÜ ‚ãÉ xn_i ‚àà f_set l, B(xn_i, Œ±) := by
      rw [Set.subset_def]
      intro t ht
      simp
      use t
      apply And.intro
      exact ht
      rw [dist_sep_eq_zero]
      exact hŒ±
    apply Set.not_mem_subset g (h_new (f_set l)).2 at h_in
    exact h_in
    have not_in_ball: (new (f_set l)) ‚àâ B(new (f_set k), Œ±):= by
      have h := (h_new (f_set l)).2
      simp
      simp at h
      exact h (new (f_set k)) h_in
    simp at not_in_ball
    exact not_in_ball

  obtain ‚ü®x, hx‚ü© := h'
  use x
  intro f l hf h_lim
  have h_cauchy := Converg_Cauchy (x ‚àò f) h_lim
  specialize h_cauchy Œ± hŒ±
  obtain ‚ü®N, hN‚ü© := h_cauchy
  specialize hN N (Nat.le_refl N) (N+1) (Nat.le_succ N)
  simp at hN
  unfold strictement_croissante at hf
  have contradiction:= (hx (f N) (f (N+1)) (hf (N+1) N (Nat.lt_succ_self N))).2
  linarith
\end{minted}

Commentons cette longue preuve et voyons comment intervient le "petit lemme" pr√©c√©dent. Nous pr√©cisons que \lean{Fin n} correspond √† l'ensemble des entiers naturels compris entre \lean{0} et \lean{n}, \lean{List.ofFn x} correspond √† la liste contenant les valeurs ordonn√©es prise par \lean{x}. Le code est divis√© en trois parties par des saut de lignes. Expliquons chacune d'elle bri√®vement :

\begin{enumerate}
    \item On r√©sonne par contrapos√©e. L'hypoth√®se \lean{h} se d√©duit alors simplement de \lean{Hx} qui est la n√©gation du but. Elle nous permet d'√©tablir \lean{H} qui prend en argument un ensemble fini au lieu d'une famille fini. C'est donc seulement une r√©√©criture plus simple de \lean{h}. Pour ce faire, nous convertissons l'ensemble \lean{A} en liste par \lean{Finset.toList}. Nous posons une suite de \lean{Fin s.length} dans \lean{X}, o√π \lean{s.length} est la longueur de la liste. Ces √©l√©ments nous permettent alors d'utiliser \lean{h}, et la propri√©t√© obtenue doit √™tre adapt√©e pour correspondre √† notre but. Ainsi en quelques √©tapes nous rempla√ßons \lean{List.ofFn x} par \lean{A}.
    \item Comme pr√©vu l'hypoth√®se \lean{H} nous permet d'obtenir \lean{h'} ! Il suffit simplement de reprendre la preuve du "petit lemme" en l'adaptant √† notre contexte...
    \item Enfin nous montrons que la suite obtenue n'admet pas de valeur d'adh√©rence.
\end{enumerate}

Ici s'ach√®ve nos travaux sur la compacit√©, ce dernier lemme pourrait √™tre utilis√© pour prouver le th√©or√®me suivant: un espace m√©trique est compacte si et seulement si il est complet et pr√©compact.

\newpage
\section{Conclusion}

\subsection{Perspectives d‚Äôapprofondissement}

Nos travaux sur la compacit√© et la compl√©tude peuvent encore √™tre enrichis de preuves suppl√©mentaires, nous en ajouterons probablement quelques une dans notre r√©pertoire git. Travailler plus en profondeur sur les manuels nous permettrait √©galement de revoir l‚Äôensemble de notre code en le rendant plus soign√© et plus concis. Enfin, pour aller plus loin, notre code pourrait √™tre adapt√© au logiciel D$\exists\forall$DUCTION.


\subsection{Int√©r√™t p√©dagogique}

Programmer en Lean nous a permis de prendre conscience de l‚Äôimportance des hypoth√®ses dans une d√©monstration. Cela nous a aussi aider √† structurer notre raisonnement. En effet, l‚Äôinterface de l‚Äô√©diteur de code permet de visualiser chaque √©tape du raisonnement et nous offre un retour instantan√© sur la validit√© des arguments. Ainsi nous pouvons nous corriger facilement. Enfin, Lean permet d'explorer les fondements logiques des math√©matiques, de mettre en lumi√®re ces choses sous-entendus ou implicites des math√©matiques habituelles, ainsi que les axiomes de base et les r√®gles d'inf√©rence.


\subsection{Comp√©tences acquises gr√¢ce au travail de groupe}

Nous avons d√©couvert l‚Äôimportance d‚Äôune bonne communication lors d‚Äôun travail en groupe. Les r√©unions r√©guli√®res nous permettaient de faire le point sur l‚Äôavancement de chacun. Nous communiquions aussi √† distance pour demander de l‚Äôaide ou en apporter. Cependant nous avons choisi d√®s le d√©but de r√©partir le code entre nous trois. Cette r√©partition aurait √©t√© plus efficace si nous avions pr√©alablement appris ensemble a coder. La prise en main de Lean s‚Äôest en effet √©tal√© sur une tr√®s longue p√©riode car chacun apprenait de son cot√©. Nous aurions alors pu aller encore plus loin dans la formalisation de la topologie en Lean.

\newpage

\appendix

\section{M√©ta programmation}

Une \textbf{monade} est une abstraction en programmation fonctionnelle. C'est une structure ayant pour fonction d'encapsuler des donn√©es dans une bo√Æte elle m√™me porteuse d'informations. Quelques exemples usuels :

\begin{itemize}
    \item \haskell{Maybe} dot√© de deux constructeurs \haskell{Just} et \haskell{Nothing} tel que \haskell{Just} prenne un argument, permet de repr√©senter des proc√©dures ne renvoyant pas forc√©ment une valeur.
    \item \haskell{State s} qui repr√©sente une proc√©dure avec un √©tat de type \haskell{s}, que l'on peut modifier au cours de la proc√©dure.
    \item \haskell{Reader} qui repr√©sente une proc√©dure ayant acc√®s √† un environnement (ou contexte) en lecture seule.
\end{itemize}

En Lean, une tactique peut donc √™tre vu comme une instruction qui manipule \textit{l'√©tat} de la preuve et ayant acc√®s √† un \textit{contexte}. Une tactique est repr√©sent√©e comme une monade \lean{TacticM}, c'est √† dire \lean{ReaderT Context $ StateRefT State TermElabM} (on dit que \lean{TacticM} √©tend \lean{TermElabM} avec un √©tat et un contexte).

On d√©taille ici le code de la tactique \lean{custom_assump} (voir section \ref{code:custom_assump} pour l'id√©e g√©n√©rale) :

\begin{minted}{lean}
elab "custom_assump" : tactic =>
  Lean.Elab.Tactic.withMainContext do
    let goal ‚ÜêLean.Elab.Tactic.getMainGoal
    let goalType ‚ÜêLean.Elab.Tactic.getMainTarget
    let ctx ‚ÜêLean.MonadLCtx.getLCtx
    let option_matching_expr ‚Üêctx.findDeclM? fun decl: Lean.LocalDecl => do
      let declExpr := decl.toExpr
      let declType ‚ÜêLean.Meta.inferType declExpr
      if ‚ÜêLean.Meta.isExprDefEq declType goalType
        then return Option.some declExpr
        else return Option.none
    match option_matching_expr with
    | some e => Lean.Elab.Tactic.closeMainGoal e
    | none =>
      Lean.Meta.throwTacticEx `custom_assump goal
        (m!"unable to find matching hypothesis of type ({goalType})")
\end{minted}

\begin{itemize}
    \item On commence par d√©finir la tactique \lean{custom_assump} avec l'annotation \lean{tactic}, qui classifie la syntaxe "\lean{custom_assump}" dans la cat√©gorie syntaxique \lean{tactic}. Le corps de la tactique est ce qui suit \lean{=>} : un terme de type \lean{TacticM Unit}.
    \item La premi√®re instruction, \lean{Lean.Elab.Tactic.withMainContext} place la proc√©dure qui suit dans le contexte de la preuve en cours.
    \item On peut alors obtenir du contexte le but et le type du but, c'est √† dire la proposition √† prouver (lignes 3 et 4)
    \item On peut aussi obtenir la liste des hypoth√®ses (ligne 5), stock√©es dans une structure appel√©e \lean{LocalContext}. On extrait a liste des d√©clarations (de type \lean{LocalDeclarations}) √† travers laquelle on it√®re (ligne 6). Pour chaque d√©claration :
        \begin{itemize}
            \item On obtient l'expression de la d√©claration (ligne 7) et on inf√®re son type (ligne 8)
            \item On peut alors v√©rifier le ce type est d√©finitionnellement √©gal au type du but (ligne 9), et si c'est le cas on peut retourner l'expression (ligne 10).
        \end{itemize}
    \item On v√©rifie alors si l'une des expressions a bien le bon type. Si l'it√©ration a retourn√© une expression, on cl√¥t le but avec celle ci (ligne 13). Sinon, on renvoie une erreur avec le nom de la tactique, le but et le message √† afficher.
\end{itemize}

\newpage

\selectlanguage{french} % Doesn't work ???
\nocite{*}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
