%! TeX program = lualatex
\documentclass[a4paper, 12pt]{article}

\usepackage{fontspec}
\usepackage{multicol}
\usepackage[french]{babel}
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}
\usepackage{enumitem}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{wrapfig}
\usepackage[french]{datetime}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{array}
\usepackage{hyperref}
\usepackage{minted}

% Required for UTF-8 characters in minted env
\setmonofont{FiraCode}

\setminted[lean]{linenos, fontsize=\footnotesize}

\newcommand{\lean}[1]{\mintinline{lean}{#1}}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    pdftitle={Démonstration assistée par ordinateur},
}

\urlstyle{same}

\begin{document}

\begin{titlepage}

    \begin{figure}
        \centering
        % \includegraphics[width=8cm]{logo.png} % Logo Sorbonne
        \vspace{8cm}
    \end{figure}

    \vspace{6cm}

    \begin{center}
        {\Huge Démonstration assistée par ordinateur\\}
        \vspace{0.5cm}
        {\huge Rapport de mi-parcours\\}

        \vspace{1.5cm}

        {\large Luc Saccoccio--Le Guennec\\ Nour Bouabid\\ Charles De Vergeron}
        \vfill
        {\large \today}
        \pagebreak
    \end{center}

\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}

\subsection{Assistants de preuves}

Un assistant de preuve est un logiciel permettant l'écriture d'énoncés logiques et la vérification de preuves formelles. Il existe de nombreux assistants de preuves, parmi lesquels on peux citer :

\begin{itemize}
    \item Coq, développé en OCaml par l'équipe \href{http://www.pps.univ-paris-diderot.fr/pi.r2/}{PI.R2}
    \item Isabelle, développé en Standard ML et Scala
    \item Agda, développé en Haskell
\end{itemize}

On peut noter qu'ils diffèrent sur de nombreux points. En prenant Coq comme standard :

\begin{itemize}
    \item Isabelle n'est pas en capacité de raisonner avec des types dépendants
    \item Agda ne dispose pas de mécanismes d'automatisation de preuves
\end{itemize}

Qui plus est, il existe des langages de programmation dont le système de types permet la formalisation de certains énoncés, comme Haskell; ou n'ayant pas pour objectif de permettre la formalisation d'énoncés mathématiques mais plutôt la vérification de programmes informatiques, comme F*.

Le fonctionnement des assistants de preuves, autrement dit ce qui permet de s'assurer que l'assistant comprend bien les énoncés que nous encodons et qu'il a en effet raison lorsqu'il affirme que notre preuve est (ou n'est pas) acceptable; repose sur la, ou plutôt une théorie des types.

\subsection{Petit historique}

Ce qui suit est un historique extrêmement concis et réducteur de plus de 2 000 ans d'histoire d'une certaine branche de la logique.

L'histoire de la formalisation des mathématiques commence avec Aristote et l'introduction de la méthode axiomatique et de règles logiques. Après de nombreuses péripéties, on peut considérer que ces objectifs furent atteint par Frege pour la logique classique, et par Heyting pour la logique intuitionniste. Cette considération est néanmoins discutable, et en 1910 Whitehead et Russell introduisirent la notion de type pour y remédier dans les volumineux \textit{Principia Mathematica}. Malgré son efficacité à résoudre les problèmes ayant motivé sa création, c'est à dire les paradoxes de la théorie naïve des ensembles de Frege, cette théorie était assez rigide et ne formalisait pas le mécanisme de substitution. C'est avec le $\lambda$-calcul d'Alonzo Church en 1940 que ce mécanisme est formalisé, et il crée la théorie des types simples. En 1934 puis en 1958, Haskell Curry remarque qu'il y a une forme de correspondance entre les types et les schémas d'axiomes intuitionnistes, puis de même entre certains modèles de preuves et certains modèles de calcul. Enfin, en 1969, William Alvin Howard observe que la déduction naturelle peut s'interpréter comme sa version intuitionniste vu comme une version typée du $\lambda$-calcul :

\begin{center}
    Il y a un isomorphisme entre les $\lambda$-termes et les preuves, et entre leurs types et les énoncés logiques.
\end{center}

C'est la correspondance de Curry-Howard(-Lambek pour la version catégoriste)

Dans les années 70, de Bruijn étend le système de types en introduisant les types dépendants avec pour objectif affiché de formaliser et vérifier les mathématiques. Il crée alors le premier assistant de preuve, \textbf{AUTOMATH}. En 1973, un autre assistant de preuve, Mizar, est développé, mais sur des bases ensemblistes (en particulier la théorie des ensembles de Tarski-Grothendieck). Il est publié en 1989. Mais à partir des années 80, il y a une explosion de la recherche en ce domaine, avec Per Martin-Löf, Girard et Barendregt...

L'histoire est parcellée de péripéties, mais nous finirons cet historique en 2004 avec la formalisation en Coq du théorème des quatres couleurs. Bien que ce résultat fut prouvé maintes fois (en 1976 par Appel et Haken, 1996, 1997...) y compris sur des assistants de preuves, la formalisation en Coq réduit d'une part les programmes à un seul : le noyau de Coq, et d'autre part automatise les très nombreux configurations à prendre en compte.

\subsection{Ce projet}

Ce projet a pour but d'implémenter une partie de notre cours de topologie métrique (LU3MA260) dans l'assistance de preuve \href{https://lean-lang.org/}{Lean}. Cela implique donc de commencer par définir les objets étudiés (espaces métriques, boules, applications continues...) puis d'encoder et de vérifier nos théorèmes et preuves.

\section{Lean}

Pour ce projet, nous utiliserons l'assistant de preuves Lean (version 4.5.0 lors de l'écriture de ce rapport). Il y a plusieurs raisons pour ce choix parmi lesquelles :
\begin{itemize}
    \item L'environnement de développement interactif
    \item Le support natif des caractères unicode
    \item Les capacités de méta programmation
\end{itemize}

Outre, bien entendu, son utilisation dans D$\exists\forall$DUCTION \cite{deaduction}, sa simplicité d'apprentissage, la documentation (\cite{theorem_proving}, \cite{math_in_lean}) et la communauté Lean sur Zulip pouvant répondre à nos interrogations.

Nous utilisons essentiellement Mathlib, une librairie contenant un vaste ensemble de résultats mathématiques, pour des structures usuelles comme les réels ainsi que pour conclure des preuves nécessitant la manipulation d'inégalités, cela n'était pas très intéressant.

\subsection{Histoire}

Lean est un langage open-source développé depuis 2013 basé sur le calcul des constructions (la version du lambda-calcul la plus "forte" selon la classification de Barendregt \cite{Barendregt_1991}), tout comme Coq. Bien que les premiers essais aient contenus des fondations alternatives (notamment la théorie homotopique des types), en 2017 sort Lean 3, la première version stable implémentée majoritairement en C++. En 2021 commence Lean 4, une réimplémentation de Lean majoritairement en Lean avec certaines parties en C++. Cette version contient en outre un système de macros extrêmement puissant qui permet d'implémenter et de modifier un ensembles de composants du frontend en Lean plutôt qu'en C++.

\subsection{Cycle de développement}

Un projet Lean commence par la création d'un dossier dédié à l'aide du programme \texttt{lake}. On peut alors préciser que l'on compte utiliser Mathlib dans le fichier \texttt{lakefile.lean}. Ensuite on peut commencer à programmer ou prouver des résultats. Seul le second cas nous intéresse. L'arborescence d'un projet Lean consiste en un unique dossier portant le nom du projet, lequel contient un ensemble de dossiers et de fichiers Lean.

\subsection{Méta programmation}


\section{La topologie métrique en Lean}

\subsection{Contexte et mise en place}

Le cours de topologie LU3MA260\cite{topology_memo} est divisé 5 parties et 2 appendices :

\begin{itemize}
    \item Espaces métriques
    \item Complétude
    \item Compacité
    \item Connexité
    \item Espaces vectoriels normés, espaces de Banach
    \item Appendice I : ensembles et applications
    \item Appendice II : quelques schémas
\end{itemize}

Nous laisserons de côté les appendices ainsi que la dernière section sur les espaces vectoriels normés et les espaces de Banach.

\subsection{Espaces métriques}

On commence par définir un espace métrique. C'est une classe de types sur lesquels on peut définir une "distance", c'est à dire la donnée de l'application et des propriétés qu'elle vérifie :

\begin{minted}{lean}
class MetricSpace (α : Type u) where
    dist : α → α → ℝ
    dist_pos : ∀ {x y : α}, 0 ≤ dist x y
    dist_sep : ∀ {x y : α}, dist x y = 0 ↔ x = y
    dist_symm : ∀ {x y : α}, dist x y = dist y x
    dist_triangle : ∀ {x y z : α}, dist x z ≤ dist x y + dist y z

variable {X : Type u} [MetricSpace X]
\end{minted}

La dernière instruction, \lean{variable}, permet de définir dans le contexte (soit le fichier, soit la \lean{section} dans laquelle on se trouve) des variables. Ici, nous nous sommes donnés un type \lean{X} dans l'univers \lean{u}, ainsi qu'une instance de la classe \lean{MetricSpace} pour le type \lean{X}. En termes mathématiques, nous nous sommes donnés un espace métrique $X$.

On définit ensuite les boules ouvertes et on introduit la notation usuelle $B(x, r)$ pour la boule de rayon $r$ centrée en $x$. Le type \lean{Set X} est le type des ensembles à valeurs dans \lean{X}.

\begin{minted}{lean}
def open_ball (x : X) (r : ℝ) : Set X := {y | d x y < r}

notation "B(" x "," r ")" => open_ball x r
\end{minted}

Il est très pratique d'introduire un ensemble de lemmes relativement évidents qui faciliteront les preuves. Ils sont tous marqués avec \lean{@[simp]}, ce qui indique à Lean qu'il peut les utiliser lors de l'application des tactiques `simp` :

\begin{minted}{lean}
@[simp]
lemma dist_sep_eq_zero (x : X) : d x x = 0 := dist_sep.mpr rfl

@[simp]
lemma mem_open_ball (x : X) (r : ℝ) (y : X) : y ∈ B(x, r) ↔ dist x y < r := Iff.rfl

@[simp]
lemma center_in_ball (x : X) (r : ℝ) : r > 0 → x ∈ B(x, r) := by
  intro r_pos
  simpa [open_ball]
\end{minted}

On finit enfin par la définition d'un ouvert. C'est un objet de type \lean{Prop}, autrement dit un énoncé mathématique, paramétré par l'ouvert $U$.

\begin{minted}{lean}
def is_open (U : Set X) : Prop := ∀ x ∈ U, ∃ r > 0, B(x, r) ⊆ U
\end{minted}

On peut alors montrer un premier résultats, c'est à dire que le boule ouverte est bien ouverte :

\begin{minted}{lean}
lemma open_ball_is_open : ∀ x : X, ∀ r > 0, is_open B(x, r) :=
  by
    intros x r _ y y_in
    set ε := r - d x y with hε
    use ε
    apply And.intro
    . simp [open_ball] at y_in
      linarith only [hε, y_in]
    . intros z z_in
      rw [mem_open_ball] at *
      have p : d x z ≤ d x y + d y z := dist_triangle
      linarith only [p, z_in, y_in, hε]
\end{minted}

Pour ce qui est de la preuve, elle suit le raisonnement suivant :

\begin{itemize}
    \item On introduit les variables \lean{x}, \lean{r}, \lean{y} et l'hypothèse \lean{y_in} que \lean{y} est dans la boule \lean{B(x, r)}.
\end{itemize}

La preuve consiste en l'introduction de \lean{x}, \lean{r}, \lean{y} et de l'hypothèse que \lean{y} est dans la boule \lean{B(x, r)} (l'underscore après \lean{r} signifie simplement que l'on ne nomme pas l'hypothèse que \lean{r} est positif). On peut ensuite définir notre $ε$ ainsi que l'hypothèse \lean{hε} qui a pour type \lean{ε = r - d x y}. Puisque \lean{is_open U} a pour type \lean{∀ x ∈ U, ∃ r > 0, B(x, r) ⊆ U}, il faut donc montrer \lean{∃ r > 0, B(x, r) ⊆ U}. Cette syntaxe signifie en réalité \lean{∃ r, r > 0 ∧ B(x, r) ⊆ U} (\lean{∃} étant une syntaxe pour le type inductif \lean{Exists} paramétré par \lean{w} et \lean{h}, l'élément et la propriété sur cet élément). On indique donc que l'on utilise \lean{ε} et il reste à montrer la positivité et l'inclusion de la boule. La positivité s'obtient en revenant à la définition d'une boule ouverte puis en appliquant la tactique \lean{linarith} qui résout un but à l'aide d'arithmétique linéaire.

\subsection{Complétude}

La complétude nécessite un certain nombre de définitions , telles que les suites de Cauchy, la caracetrisation séquentielle de la fermeture par exemple.

La premiere chose a définir est une suite de Cauchy : 
\begin{minted}{lean}
def CauchySeq (u : ℕ → X) := ∀ ε > 0, ∃ N : ℕ , ∀ m ≥ N,∀ n ≥ N,  d (u m) (u n) < ε
\end{minted}

On rappelle que " d " est la distance definit plus haut.

 Le lemme suivant est assez simple dans le raisonnement. Il m' a aidé dans la prise en main et la comprehesion de Lean. 

\begin{minted}{lean}
theorem Converg_Cauchy (u : ℕ → X) : Converg u → CauchySeq u :=
  by
    intro ⟨l, hl⟩
    intro ε ε_pos
    have Hε : 0 < ε / 2 := by linarith
    obtain ⟨N, hN⟩ := hl ε/2
    use N
    intro m hm
    intro n hn
    have hd : d (u n) (u m) ≤ d (u n) l + d l (u m) := dist_triangle
    have h₁ : d (u n) l < ε/2 := @dist_symm X _ _ _ ▸ hN n hn
    have h₂ : d (u m) l < ε/2 := @dist_symm X _ _ _ ▸ hN m hm
    have hε := add_lt_add h₁ h₂
    have h : d (u n) (u m) < ε/2 + ε/2 := lt_trans hd hε
    have E : ε/2 + ε/2 = ε := by linarith
    have H : d (u n) (u m) < ε
    
\end{minted}

Il s agit de la preuve qu une suite de cauchy est convergente.
L' instruction " intro ⟨l, hl⟩ "  introduit  l hypothèse de convergence en utilisant l existance de la limite  " l "  ainsi que en la notant hl.  Nous disposons maintenant de l énoncé general :  $$ \forall  \varepsilon \ge 0 \exists N \in \mathbb{N},\forall n \geq N, d (u n) ( l ) < \varepsilon$$  . Nous introduisons donc la  quantité $\varepsilon$ que nous divisons par 2 dans l hypothese He pour la suite de la preuve. 
Grace a l hypothese, nous avons un N entier appliqué a cet  $\varepsilon$/2  par " obtain ⟨N, hN⟩ := hl ε/2 hl "
 qui est utilisé avec " use N". 
 On invoque un n et m > N pour con
 tinuer de parcourir l hypothése pour arriver au coeur de la preuve de ce lemme.

 Nous avons besoin de deux énoncés :
                - hd qui consiste a montrer que " d (u n) (u m) ≤ d (u n) l + d l (u m) " par l inegalité triangulaire
                -  h1 et h2 utilisent l hypothese de convergence appliquée respectivement au n et m et $\varepsilon$/2
    les énoncés he et h condensent les inégalités precédentes avec successivement \\
        - $a \leq b $ et $ c\leq d$ \implies $ a+b \leq c+d$ ( add_lt_add )  \\ 
        - $a \leq b $ et $ b \leq c $ \implies $ a\leq c$ ( lt_trans )  appliquée a hd et he\\ 

Il ne nous reste plus qu'à préciser a lean que  " ε/2 + ε/2 = ε " grace a la tactic linarith pour finaliser la preuve. \\ 


Le second lemme est le caractère bornée des suites de Cauchy :

\begin{minted}{lean}

lemma Cauchy_borne ( u : ℕ → X ) : (h : CauchySeq u ) → Bornee u := by

    unfold CauchySeq
    unfold Bornee
    intro h
    specialize h ( 1: ℝ )
    have h1 : (1:ℝ) >0 := by
      simp
    specialize h h1
    obtain ⟨N, hN⟩ := h
    have fintype.D := { d (u N) (u n) | n : Fin (N-1)} 
    -- have M := D.max
    intro n
    
\end{minted}

La tactique unfold déploit les defintions de CauchySeq et Bornee dans les hypothèses et le goal. 
Nous introduisons l hypothèse h qui est le fait que la suite u est de Cauchy. Le début de h étant une généralité, nous spécialisons le epsilon en 1 pour faciliter la preuve.  ( En effet, sans spécifier le epsilon choisit, il faudrait utiliser l axiome du choix  ). L'énonce h1 montre que 1 pris dans les réels est bien strictement positif, critère que doit valider tout choix d epsilon. Comme précédemment, la tactique  " obtain ⟨N, hN⟩ " donne le N associé a 1 ( vu comme un epsilon quelconque ) et note hN la suite de l'énoncé : " hN : ∀ m ≥ N, ∀ n ≥ N, d (u m) (u n) < 1 ". La suite de la preuve consiste en la recherche d un majorant M réel a l ensemble des distances possibles entre les termes de la suite et un point x de X. Ici, nous choisissons le N ieme terme de la suite u comme point de reference.
De deux choses l une: \\ 

        - si $M \geq 1$, M majore alors tous les termes de la suite d (u N) (u n)\\
        - si $M \leq  1$ , M <- 1 et 1 est un majorant de la suite d (u N) (u n) \\
        
On définit  \textbf{$D := { d (u N) (u n) tel que n \leq N-1 }$}, l ensemble des distances entre u(N) et tous les autres termes u d incides inferieurs a N. On note M le max de cet ensemble. 
Une autre méthode, plus alghorithmique, serait de faire une induction sur n < N : \\
        - poser M = d (u N) (u 0) puis comparer M aux autres distances. Des que M est depassé par une distance, ce nouveau majorant remplace l ancienne valeur de M. 

Supposons le M obtenu, il reste a majoré les termes d indices superieures a N. Ils le sont dés le depart par l hypothése que la suite est de Cauchy. 
Le majorant de la suite sera donc le maximum entre M et 1, comme annoncé.


Il reste a montrer le théoreme central de ce chapitre : le théoreme du point fixe contractant de Banach picard.

\begin{minted}{lean}

theorem Point_Fixe_Contractant (f : X -> X ) : (Complet X ∧ contractant f ∧ ∀ u :ℕ -> X,  ∀ n , f (u n) = u (Nat.succ n )) -> (∃!x:X,f x =x ∧ lim u x) :=
  by
    unfold contractant
    have C := d ( u 0 ) ( u 1)
    intro H
    obtain ⟨k, hk⟩ := H.2
    
    have h : ∀ n : ℕ , d (u (Nat.succ n)) (u n) < k^n*C := sorry
    -- cf exercice 50 du poly de topo
    
    have l : ∀ ε>0 ,∃ N , ∀ n > N ,d (u (Nat.succ n)) (u n) < ε := sorry
    -- preuve que k^n*C tend vers zero puis thm des gendarmes
    
    have hp : ∀ n p : ℕ , d (u n) (u (n + p)) < ((k^n)/(1-k))*C := sorry
    -- IT generalisée et recurrence sur p
    
    have lp : ∀ ε>0 ,∃ N ,∀ p  ≥ N,∀ n ≥ N, d (u p) (u n) < ε := sorry
    -- encore une preuve de convergence vers 0
    
    have Cauchy : CauchySeq u := by exact lp
    have Conv : Converge u := by exact H.1 u Cauchy
\end{minted}

\subsection{Compacité}

\subsection{Connexité}

\newpage

\nocite{*}
\bibliographystyle{plain}
\bibliography{main}

\end{document}
